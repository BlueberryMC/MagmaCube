From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: acrylic-style <me@acrylicstyle.xyz>
Date: Fri, 25 Sep 2020 09:19:57 +0900
Subject: [PATCH] decompile fix


diff --git a/pom.xml b/pom.xml
index 92114cf6400c29989725c2a8f72155afc1241a14..631a5f6ee3989fdcbf81c48a7b3a87105e0c289f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -78,5 +78,60 @@
             <artifactId>netty-all</artifactId>
             <version>4.1.50.Final</version>
         </dependency>
+        <dependency>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <version>28.2-jre</version>
+        </dependency>
+        <dependency>
+            <groupId>com.mojang</groupId>
+            <artifactId>datafixerupper</artifactId>
+            <version>4.0.26</version>
+        </dependency>
+        <dependency>
+            <groupId>com.mojang</groupId>
+            <artifactId>brigadier</artifactId>
+            <version>1.0.17</version>
+        </dependency>
+        <dependency>
+            <groupId>com.mojang</groupId>
+            <artifactId>javabridge</artifactId>
+            <version>1.0.22</version>
+        </dependency>
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl</artifactId>
+            <version>3.2.2</version>
+        </dependency>
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl-jemalloc</artifactId>
+            <version>3.2.2</version>
+        </dependency>
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl-openal</artifactId>
+            <version>3.2.2</version>
+        </dependency>
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl-opengl</artifactId>
+            <version>3.2.2</version>
+        </dependency>
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl-glfw</artifactId>
+            <version>3.2.2</version>
+        </dependency>
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl-stb</artifactId>
+            <version>3.2.2</version>
+        </dependency>
+        <dependency>
+            <groupId>org.lwjgl</groupId>
+            <artifactId>lwjgl-tinyfd</artifactId>
+            <version>3.2.2</version>
+        </dependency>
     </dependencies>
 </project>
diff --git a/src/main/java/com/mojang/blaze3d/platform/GlStateManager.java b/src/main/java/com/mojang/blaze3d/platform/GlStateManager.java
index bdc642f44e1176941e5d112db607f1b887dea812..6b214992ce432dc65ce8af9b20f892467a9687d7 100644
--- a/src/main/java/com/mojang/blaze3d/platform/GlStateManager.java
+++ b/src/main/java/com/mojang/blaze3d/platform/GlStateManager.java
@@ -28,7 +28,7 @@ public class GlStateManager {
     MATRIX_BUFFER = (FloatBuffer)GLX.make(MemoryUtil.memAllocFloat(16), debug0 -> DebugMemoryUntracker.untrack(MemoryUtil.memAddress(debug0)));
   }
   
-  private static final AlphaState ALPHA_TEST = new AlphaState(null);
+  private static final AlphaState ALPHA_TEST = new AlphaState(); // MagmaCube - decompile fix
   
   private static final BooleanState LIGHTING = new BooleanState(2896);
   
@@ -38,23 +38,23 @@ public class GlStateManager {
     LIGHT_ENABLE = (BooleanState[])IntStream.range(0, 8).mapToObj(debug0 -> new BooleanState(16384 + debug0)).toArray(debug0 -> new BooleanState[debug0]);
   }
   
-  private static final ColorMaterialState COLOR_MATERIAL = new ColorMaterialState(null);
+  private static final ColorMaterialState COLOR_MATERIAL = new ColorMaterialState(); // MagmaCube - decompile fix
   
-  private static final BlendState BLEND = new BlendState(null);
+  private static final BlendState BLEND = new BlendState(); // MagmaCube - decompile fix
   
-  private static final DepthState DEPTH = new DepthState(null);
+  private static final DepthState DEPTH = new DepthState(); // MagmaCube - decompile fix
   
-  private static final FogState FOG = new FogState(null);
+  private static final FogState FOG = new FogState(); // MagmaCube - decompile fix
   
-  private static final CullState CULL = new CullState(null);
+  private static final CullState CULL = new CullState(); // MagmaCube - decompile fix
   
-  private static final PolygonOffsetState POLY_OFFSET = new PolygonOffsetState(null);
+  private static final PolygonOffsetState POLY_OFFSET = new PolygonOffsetState(); // MagmaCube - decompile fix
   
-  private static final ColorLogicState COLOR_LOGIC = new ColorLogicState(null);
+  private static final ColorLogicState COLOR_LOGIC = new ColorLogicState(); // MagmaCube - decompile fix
   
-  private static final TexGenState TEX_GEN = new TexGenState(null);
+  private static final TexGenState TEX_GEN = new TexGenState(); // MagmaCube - decompile fix
   
-  private static final StencilState STENCIL = new StencilState(null);
+  private static final StencilState STENCIL = new StencilState(); // MagmaCube - decompile fix
   
   private static final FloatBuffer FLOAT_ARG_BUFFER = MemoryTracker.createFloatBuffer(4);
   
@@ -63,14 +63,14 @@ public class GlStateManager {
   private static final TextureState[] TEXTURES;
   
   static {
-    TEXTURES = (TextureState[])IntStream.range(0, 12).mapToObj(debug0 -> new TextureState(null)).toArray(debug0 -> new TextureState[debug0]);
+    TEXTURES = (TextureState[])IntStream.range(0, 12).mapToObj(debug0 -> new TextureState()).toArray(debug0 -> new TextureState[debug0]); // MagmaCube - decompile fix
   }
   
   private static int shadeModel = 7425;
   
   private static final BooleanState RESCALE_NORMAL = new BooleanState(32826);
   
-  private static final ColorMask COLOR_MASK = new ColorMask(null);
+  private static final ColorMask COLOR_MASK = new ColorMask(); // MagmaCube - decompile fix
   
   private static final Color COLOR = new Color();
   
@@ -444,7 +444,7 @@ public class GlStateManager {
   
   public static void _glBindFramebuffer(int debug0, int debug1) {
     RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
-    switch (null.$SwitchMap$com$mojang$blaze3d$platform$GlStateManager$FboMode[fboMode.ordinal()]) {
+    switch (fboMode.ordinal()) { // MagmaCube - decompile fix
       case 1:
         GL30.glBindFramebuffer(debug0, debug1);
         break;
@@ -459,7 +459,7 @@ public class GlStateManager {
   
   public static int getFramebufferDepthTexture() {
     RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
-    switch (null.$SwitchMap$com$mojang$blaze3d$platform$GlStateManager$FboMode[fboMode.ordinal()]) {
+    switch (fboMode.ordinal()) { // MagmaCube - decompile fix
       case 1:
         if (GL30.glGetFramebufferAttachmentParameteri(36160, 36096, 36048) == 5890)
           return GL30.glGetFramebufferAttachmentParameteri(36160, 36096, 36049); 
@@ -478,7 +478,7 @@ public class GlStateManager {
   
   public static void _glBlitFrameBuffer(int debug0, int debug1, int debug2, int debug3, int debug4, int debug5, int debug6, int debug7, int debug8, int debug9) {
     RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
-    switch (null.$SwitchMap$com$mojang$blaze3d$platform$GlStateManager$FboBlitMode[fboBlitMode.ordinal()]) {
+    switch (fboBlitMode.ordinal()) { // MagmaCube - decompile fix
       case 1:
         GL30.glBlitFramebuffer(debug0, debug1, debug2, debug3, debug4, debug5, debug6, debug7, debug8, debug9);
         break;
@@ -490,7 +490,7 @@ public class GlStateManager {
   
   public static void _glDeleteFramebuffers(int debug0) {
     RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
-    switch (null.$SwitchMap$com$mojang$blaze3d$platform$GlStateManager$FboMode[fboMode.ordinal()]) {
+    switch (fboMode.ordinal()) { // MagmaCube - decompile fix
       case 1:
         GL30.glDeleteFramebuffers(debug0);
         break;
@@ -505,7 +505,7 @@ public class GlStateManager {
   
   public static int glGenFramebuffers() {
     RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
-    switch (null.$SwitchMap$com$mojang$blaze3d$platform$GlStateManager$FboMode[fboMode.ordinal()]) {
+    switch (fboMode.ordinal()) { // MagmaCube - decompile fix
       case 1:
         return GL30.glGenFramebuffers();
       case 2:
@@ -518,7 +518,7 @@ public class GlStateManager {
   
   public static int glCheckFramebufferStatus(int debug0) {
     RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
-    switch (null.$SwitchMap$com$mojang$blaze3d$platform$GlStateManager$FboMode[fboMode.ordinal()]) {
+    switch (fboMode.ordinal()) { // MagmaCube - decompile fix
       case 1:
         return GL30.glCheckFramebufferStatus(debug0);
       case 2:
@@ -531,7 +531,7 @@ public class GlStateManager {
   
   public static void _glFramebufferTexture2D(int debug0, int debug1, int debug2, int debug3, int debug4) {
     RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
-    switch (null.$SwitchMap$com$mojang$blaze3d$platform$GlStateManager$FboMode[fboMode.ordinal()]) {
+    switch (fboMode.ordinal()) { // MagmaCube - decompile fix
       case 1:
         GL30.glFramebufferTexture2D(debug0, debug1, debug2, debug3, debug4);
         break;
@@ -720,6 +720,21 @@ public class GlStateManager {
     _getMatrix(2982, MATRIX_BUFFER);
     _multMatrix(MATRIX_BUFFER);
   }
+
+  // MagmaCube start - decompile fix
+  @Deprecated
+  public enum FogMode {
+    LINEAR(9729),
+    EXP(2048),
+    EXP2(2049);
+
+    public final int value;
+
+    FogMode(int debug3) {
+      this.value = debug3;
+    }
+  }
+  // MagmaCube end - decompile fix
   
   @Deprecated
   public static void _enableFog() {
@@ -824,6 +839,33 @@ public class GlStateManager {
       GL11.glPolygonOffset(debug0, debug1);
     } 
   }
+
+  // MagmaCube start - decompile fix
+  public enum LogicOp {
+    AND(5377),
+    AND_INVERTED(5380),
+    AND_REVERSE(5378),
+    CLEAR(5376),
+    COPY(5379),
+    COPY_INVERTED(5388),
+    EQUIV(5385),
+    INVERT(5386),
+    NAND(5390),
+    NOOP(5381),
+    NOR(5384),
+    OR(5383),
+    OR_INVERTED(5389),
+    OR_REVERSE(5387),
+    SET(5391),
+    XOR(5382);
+
+    public final int value;
+
+    LogicOp(int debug3) {
+      this.value = debug3;
+    }
+  }
+  // MagmaCube end - decompile fix
   
   public static void _enableColorLogicOp() {
     RenderSystem.assertThread(RenderSystem::isOnRenderThread);
@@ -874,7 +916,7 @@ public class GlStateManager {
   @Deprecated
   private static TexGenCoord getTexGen(TexGen debug0) {
     RenderSystem.assertThread(RenderSystem::isOnRenderThread);
-    switch (null.$SwitchMap$com$mojang$blaze3d$platform$GlStateManager$TexGen[debug0.ordinal()]) {
+    switch (debug0.ordinal()) { // MagmaCube - decompile fix
       case 1:
         return TEX_GEN.s;
       case 2:
@@ -1261,8 +1303,294 @@ public class GlStateManager {
     RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
     return GL11.glGetInteger(debug0);
   }
-  
+
+  // MagmaCube start - decompile fix
+  public enum Viewport {
+    INSTANCE;
+
+    protected int height;
+
+    protected int width;
+
+    protected int y;
+
+    protected int x;
+  }
+
+  public enum FboMode {
+    BASE, ARB, EXT;
+  }
+
+  public enum FboBlitMode {
+    BASE, EXT, NONE;
+  }
+
   public static boolean supportsFramebufferBlit() {
     return (fboBlitMode != FboBlitMode.NONE);
   }
+
+  static class TextureState {
+    private TextureState() {}
+
+    public final GlStateManager.BooleanState enable = new GlStateManager.BooleanState(3553);
+
+    public int binding;
+  }
+
+  @Deprecated
+  static class AlphaState {
+    private AlphaState() {}
+
+    public final GlStateManager.BooleanState mode = new GlStateManager.BooleanState(3008);
+
+    public int func = 519;
+
+    public float reference = -1.0F;
+  }
+
+  @Deprecated
+  static class ColorMaterialState {
+    private ColorMaterialState() {}
+
+    public final GlStateManager.BooleanState enable = new GlStateManager.BooleanState(2903);
+
+    public int face = 1032;
+
+    public int mode = 5634;
+  }
+
+  static class BlendState {
+    private BlendState() {}
+
+    public final GlStateManager.BooleanState mode = new GlStateManager.BooleanState(3042);
+
+    public int srcRgb = 1;
+
+    public int dstRgb = 0;
+
+    public int srcAlpha = 1;
+
+    public int dstAlpha = 0;
+  }
+
+  static class DepthState {
+    private DepthState() {}
+
+    public final GlStateManager.BooleanState mode = new GlStateManager.BooleanState(2929);
+
+    public boolean mask = true;
+
+    public int func = 513;
+  }
+
+  @Deprecated
+  static class FogState {
+    private FogState() {}
+
+    public final GlStateManager.BooleanState enable = new GlStateManager.BooleanState(2912);
+
+    public int mode = 2048;
+
+    public float density = 1.0F;
+
+    public float start;
+
+    public float end = 1.0F;
+  }
+
+  static class CullState {
+    private CullState() {}
+
+    public final GlStateManager.BooleanState enable = new GlStateManager.BooleanState(2884);
+
+    public int mode = 1029;
+  }
+
+  static class PolygonOffsetState {
+    private PolygonOffsetState() {}
+
+    public final GlStateManager.BooleanState fill = new GlStateManager.BooleanState(32823);
+
+    public final GlStateManager.BooleanState line = new GlStateManager.BooleanState(10754);
+
+    public float factor;
+
+    public float units;
+  }
+
+  static class ColorLogicState {
+    private ColorLogicState() {}
+
+    public final GlStateManager.BooleanState enable = new GlStateManager.BooleanState(3058);
+
+    public int op = 5379;
+  }
+
+  static class StencilFunc {
+    private StencilFunc() {}
+
+    public int func = 519;
+
+    public int ref;
+
+    public int mask = -1;
+  }
+
+  static class StencilState {
+    private StencilState() {}
+
+    public final GlStateManager.StencilFunc func = new GlStateManager.StencilFunc();
+
+    public int mask = -1;
+
+    public int fail = 7680;
+
+    public int zfail = 7680;
+
+    public int zpass = 7680;
+  }
+
+  @Deprecated
+  static class TexGenState {
+    private TexGenState() {}
+
+    public final GlStateManager.TexGenCoord s = new GlStateManager.TexGenCoord(8192, 3168);
+
+    public final GlStateManager.TexGenCoord t = new GlStateManager.TexGenCoord(8193, 3169);
+
+    public final GlStateManager.TexGenCoord r = new GlStateManager.TexGenCoord(8194, 3170);
+
+    public final GlStateManager.TexGenCoord q = new GlStateManager.TexGenCoord(8195, 3171);
+  }
+
+  @Deprecated
+  static class TexGenCoord {
+    public final GlStateManager.BooleanState enable;
+
+    public final int coord;
+
+    public int mode = -1;
+
+    public TexGenCoord(int debug1, int debug2) {
+      this.coord = debug1;
+      this.enable = new GlStateManager.BooleanState(debug2);
+    }
+  }
+
+  @Deprecated
+  public enum TexGen {
+    S, T, R, Q;
+  }
+
+  static class ColorMask {
+    private ColorMask() {}
+
+    public boolean red = true;
+
+    public boolean green = true;
+
+    public boolean blue = true;
+
+    public boolean alpha = true;
+  }
+
+  @Deprecated
+  static class Color {
+    public float r = 1.0F;
+
+    public float g = 1.0F;
+
+    public float b = 1.0F;
+
+    public float a = 1.0F;
+
+    public Color() {
+      this(1.0F, 1.0F, 1.0F, 1.0F);
+    }
+
+    public Color(float debug1, float debug2, float debug3, float debug4) {
+      this.r = debug1;
+      this.g = debug2;
+      this.b = debug3;
+      this.a = debug4;
+    }
+  }
+
+  static class BooleanState {
+    private final int state;
+
+    private boolean enabled;
+
+    public BooleanState(int debug1) {
+      this.state = debug1;
+    }
+
+    public void disable() {
+      setEnabled(false);
+    }
+
+    public void enable() {
+      setEnabled(true);
+    }
+
+    public void setEnabled(boolean debug1) {
+      RenderSystem.assertThread(RenderSystem::isOnRenderThreadOrInit);
+      if (debug1 != this.enabled) {
+        this.enabled = debug1;
+        if (debug1) {
+          GL11.glEnable(this.state);
+        } else {
+          GL11.glDisable(this.state);
+        }
+      }
+    }
+  }
+
+  public enum SourceFactor {
+    CONSTANT_ALPHA(32771),
+    CONSTANT_COLOR(32769),
+    DST_ALPHA(772),
+    DST_COLOR(774),
+    ONE(1),
+    ONE_MINUS_CONSTANT_ALPHA(32772),
+    ONE_MINUS_CONSTANT_COLOR(32770),
+    ONE_MINUS_DST_ALPHA(773),
+    ONE_MINUS_DST_COLOR(775),
+    ONE_MINUS_SRC_ALPHA(771),
+    ONE_MINUS_SRC_COLOR(769),
+    SRC_ALPHA(770),
+    SRC_ALPHA_SATURATE(776),
+    SRC_COLOR(768),
+    ZERO(0);
+
+    public final int value;
+
+    SourceFactor(int debug3) {
+      this.value = debug3;
+    }
+  }
+
+  public enum DestFactor {
+    CONSTANT_ALPHA(32771),
+    CONSTANT_COLOR(32769),
+    DST_ALPHA(772),
+    DST_COLOR(774),
+    ONE(1),
+    ONE_MINUS_CONSTANT_ALPHA(32772),
+    ONE_MINUS_CONSTANT_COLOR(32770),
+    ONE_MINUS_DST_ALPHA(773),
+    ONE_MINUS_DST_COLOR(775),
+    ONE_MINUS_SRC_ALPHA(771),
+    ONE_MINUS_SRC_COLOR(769),
+    SRC_ALPHA(770),
+    SRC_COLOR(768),
+    ZERO(0);
+
+    public final int value;
+
+    DestFactor(int debug3) {
+      this.value = debug3;
+    }
+  }
+  // MagmaCube end - decompiel fix
 }
diff --git a/src/main/java/net/minecraft/Util.java b/src/main/java/net/minecraft/Util.java
index 415c4dbdc7cb977afcbc454f162b07015ada560a..d63303c302df877f2d772b9c516f9fa7f6ef162d 100644
--- a/src/main/java/net/minecraft/Util.java
+++ b/src/main/java/net/minecraft/Util.java
@@ -13,8 +13,15 @@ import java.io.File;
 import java.io.IOException;
 import java.lang.management.ManagementFactory;
 import java.lang.management.RuntimeMXBean;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.security.PrivilegedActionException;
 import java.time.Instant;
 import java.util.Arrays;
 import java.util.Iterator;
@@ -46,6 +53,7 @@ import net.minecraft.server.Bootstrap;
 import net.minecraft.util.Mth;
 import net.minecraft.util.datafix.DataFixers;
 import net.minecraft.world.level.block.state.properties.Property;
+import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -69,7 +77,7 @@ public class Util {
   }
   
   public static <T extends Comparable<T>> String getPropertyName(Property<T> debug0, Object debug1) {
-    return debug0.getName((Comparable)debug1);
+    return debug0.getName((T) debug1); // MagmaCube - decompile fix
   }
   
   public static String makeDescriptionId(String debug0, @Nullable ResourceLocation debug1) {
@@ -91,16 +99,27 @@ public class Util {
   }
   
   private static ExecutorService makeExecutor(String debug0) {
-    ExecutorService debug2;
+    ExecutorService debug2 = null; // MagmaCube - decompile fix
     int debug1 = Mth.clamp(Runtime.getRuntime().availableProcessors() - 1, 1, 7);
     if (debug1 <= 0) {
       ListeningExecutorService listeningExecutorService = MoreExecutors.newDirectExecutorService();
     } else {
-      debug2 = new ForkJoinPool(debug1, debug1 -> {
-            Object object = new Object(debug1);
-            object.setName("Worker-" + debug0 + "-" + WORKER_COUNT.getAndIncrement());
-            return (ForkJoinWorkerThread)object;
-          }Util::onThreadException, true);
+      // MagmaCube start - decompile fix
+      debug2 = new ForkJoinPool(debug1, debug12 -> {
+        ForkJoinWorkerThread debug22 = new ForkJoinWorkerThread(debug12) {
+          protected void onTermination(Throwable debug1) {
+            if (debug1 != null) {
+              Util.LOGGER.warn("{} died", getName(), debug1);
+            } else {
+              Util.LOGGER.debug("{} shutdown", getName());
+            }
+            super.onTermination(debug1);
+          }
+        };
+        debug22.setName("Worker-" + debug0 + "-" + WORKER_COUNT.getAndIncrement());
+        return debug22;
+      }, Util::onThreadException, true);
+      // MagmaCube end - decompile fix
     } 
     return debug2;
   }
@@ -183,6 +202,74 @@ public class Util {
     } 
     return debug2;
   }
+
+  // MagmaCube start - decompile fix
+  public enum OS {
+    LINUX,
+    SOLARIS,
+    WINDOWS {
+      protected String[] getOpenUrlArguments(URL debug1) {
+        return new String[] { "rundll32", "url.dll,FileProtocolHandler", debug1.toString() };
+      }
+    },
+    OSX {
+      protected String[] getOpenUrlArguments(URL debug1) {
+        return new String[] { "open", debug1.toString() };
+      }
+    },
+    UNKNOWN;
+
+    public void openUrl(URL debug1) {
+      try {
+        Process debug2 = AccessController.<Process>doPrivileged((PrivilegedAction<Process>) () -> {
+          try {
+            return Runtime.getRuntime().exec(getOpenUrlArguments(debug1));
+          } catch (IOException e) {
+            throw new RuntimeException(e);
+          }
+        });
+        for (String debug4 : IOUtils.readLines(debug2.getErrorStream()))
+          Util.LOGGER.error(debug4);
+        debug2.getInputStream().close();
+        debug2.getErrorStream().close();
+        debug2.getOutputStream().close();
+      } catch (IOException debug2) {
+        Util.LOGGER.error("Couldn't open url '{}'", debug1, debug2);
+      }
+    }
+
+    public void openUri(URI debug1) {
+      try {
+        openUrl(debug1.toURL());
+      } catch (MalformedURLException debug2) {
+        Util.LOGGER.error("Couldn't open uri '{}'", debug1, debug2);
+      }
+    }
+
+    public void openFile(File debug1) {
+      try {
+        openUrl(debug1.toURI().toURL());
+      } catch (MalformedURLException debug2) {
+        Util.LOGGER.error("Couldn't open file '{}'", debug1, debug2);
+      }
+    }
+
+    protected String[] getOpenUrlArguments(URL debug1) {
+      String debug2 = debug1.toString();
+      if ("file".equals(debug1.getProtocol()))
+        debug2 = debug2.replace("file:", "file://");
+      return new String[] { "xdg-open", debug2 };
+    }
+
+    public void openUri(String debug1) {
+      try {
+        openUrl((new URI(debug1)).toURL());
+      } catch (URISyntaxException |MalformedURLException|IllegalArgumentException debug2) {
+        Util.LOGGER.error("Couldn't open uri '{}'", debug1, debug2);
+      }
+    }
+  }
+  // MagmaCube end - decompile fix
   
   public static OS getPlatform() {
     String debug0 = System.getProperty("os.name").toLowerCase(Locale.ROOT);
@@ -203,7 +290,7 @@ public class Util {
   
   public static Stream<String> getVmArguments() {
     RuntimeMXBean debug0 = ManagementFactory.getRuntimeMXBean();
-    return debug0.getInputArguments().stream().filter(debug0 -> debug0.startsWith("-X"));
+    return debug0.getInputArguments().stream().filter(debug02 -> debug02.startsWith("-X")); // MagmaCube - decompile fix
   }
   
   public static <T> T lastOf(List<T> debug0) {
@@ -251,6 +338,20 @@ public class Util {
     debug1.accept(debug0);
     return debug0;
   }
+
+  // MagmaCube start - decompile fix
+  enum IdentityStrategy implements Hash.Strategy<Object> {
+    INSTANCE;
+
+    public int hashCode(Object debug1) {
+      return System.identityHashCode(debug1);
+    }
+
+    public boolean equals(Object debug1, Object debug2) {
+      return (debug1 == debug2);
+    }
+  }
+  // MagmaCube end - decompile fix
   
   public static <K> Hash.Strategy<K> identityStrategy() {
     return (Hash.Strategy<K>)IdentityStrategy.INSTANCE;
@@ -258,14 +359,14 @@ public class Util {
   
   public static <V> CompletableFuture<List<V>> sequence(List<? extends CompletableFuture<? extends V>> debug0) {
     List<V> debug1 = Lists.newArrayListWithCapacity(debug0.size());
-    CompletableFuture[] arrayOfCompletableFuture = new CompletableFuture[debug0.size()];
+    CompletableFuture[] arrayOfCompletableFuture = new CompletableFuture[debug0.size()]; // MagmaCube - decompile fix
     CompletableFuture<Void> debug3 = new CompletableFuture<>();
-    debug0.forEach(debug3 -> {
+    debug0.forEach(future -> { // MagmaCube - decompile fix
           int debug4 = debug0.size();
           debug0.add(null);
-          debug1[debug4] = debug3.whenComplete(());
+          arrayOfCompletableFuture[debug4] = future.whenComplete(null); // MagmaCube - decompile fix
         });
-    return CompletableFuture.allOf((CompletableFuture<?>[])arrayOfCompletableFuture).applyToEither(debug3, debug1 -> debug0);
+    return (CompletableFuture) CompletableFuture.allOf((CompletableFuture<?>[])arrayOfCompletableFuture).applyToEither(debug3, debug12 -> debug0); // MagmaCube - decompile fix
   }
   
   public static <T> Stream<T> toStream(Optional<? extends T> debug0) {
@@ -315,21 +416,73 @@ public class Util {
   public static int getRandom(int[] debug0, Random debug1) {
     return debug0[debug1.nextInt(debug0.length)];
   }
-  
-  private static BooleanSupplier createRenamer(Path debug0, Path debug1) {
-    return (BooleanSupplier)new Object(debug0, debug1);
+
+  // MagmaCube start - decompile fix
+  private static BooleanSupplier createRenamer(Path from, Path to) {
+    return new BooleanSupplier() {
+      public boolean getAsBoolean() {
+        try {
+          Files.move(from, to, new java.nio.file.CopyOption[0]);
+          return true;
+        } catch (IOException debug1) {
+          Util.LOGGER.error("Failed to rename", debug1);
+          return false;
+        }
+      }
+
+      public String toString() {
+        return "rename " + from + " to " + to;
+      }
+    };
+    // MagmaCube end - decompile fix
   }
-  
-  private static BooleanSupplier createDeleter(Path debug0) {
-    return (BooleanSupplier)new Object(debug0);
+
+  // MagmaCube start - decompile fix
+  private static BooleanSupplier createDeleter(Path target) {
+    return new BooleanSupplier() {
+      public boolean getAsBoolean() {
+        try {
+          Files.deleteIfExists(target);
+          return true;
+        } catch (IOException debug1) {
+          Util.LOGGER.warn("Failed to delete", debug1);
+          return false;
+        }
+      }
+
+      public String toString() {
+        return "delete old " + target;
+      }
+    };
+    // MagmaCube end - decompile fix
   }
-  
-  private static BooleanSupplier createFileDeletedCheck(Path debug0) {
-    return (BooleanSupplier)new Object(debug0);
+
+  // MagmaCube start - decompile fix
+  private static BooleanSupplier createFileDeletedCheck(Path target) {
+    return new BooleanSupplier() {
+      public boolean getAsBoolean() {
+        return !Files.exists(target, new java.nio.file.LinkOption[0]);
+      }
+
+      public String toString() {
+        return "verify that " + target + " is deleted";
+      }
+    };
+    // MagmaCube end - decompile fix
   }
-  
-  private static BooleanSupplier createFileCreatedCheck(Path debug0) {
-    return (BooleanSupplier)new Object(debug0);
+
+  // MagmaCube start - decompile fix
+  private static BooleanSupplier createFileCreatedCheck(Path target) {
+    return new BooleanSupplier() {
+      public boolean getAsBoolean() {
+        return Files.isRegularFile(target, new java.nio.file.LinkOption[0]);
+      }
+
+      public String toString() {
+        return "verify that " + target + " is present";
+      }
+    };
+    // MagmaCube end - decompile fix
   }
   
   private static boolean executeInSequence(BooleanSupplier... debug0) {
@@ -391,7 +544,7 @@ public class Util {
   }
   
   public static Consumer<String> prefix(String debug0, Consumer<String> debug1) {
-    return debug2 -> debug0.accept(debug1 + debug2);
+    return debug2 -> debug1.accept(debug0 + debug2); // MagmaCube - decompile fix
   }
   
   public static DataResult<int[]> fixedSize(IntStream debug0, int debug1) {
@@ -406,7 +559,7 @@ public class Util {
   }
   
   public static void startTimerHackThread() {
-    Object object = new Object("Timer hack thread");
+    Thread object = new Thread("Timer hack thread"); // MagmaCube - decompile fix
     object.setDaemon(true);
     object.setUncaughtExceptionHandler((Thread.UncaughtExceptionHandler)new DefaultUncaughtExceptionHandler(LOGGER));
     object.start();
@@ -419,6 +572,6 @@ public class Util {
   }
   
   public static String sanitizeName(String debug0, CharPredicate debug1) {
-    return debug0.toLowerCase(Locale.ROOT).chars().<CharSequence>mapToObj(debug1 -> debug0.test((char)debug1) ? Character.toString((char)debug1) : "_").collect(Collectors.joining());
+    return debug0.toLowerCase(Locale.ROOT).chars().<CharSequence>mapToObj(debug12 -> debug1.test((char)debug12) ? Character.toString((char)debug12) : "_").collect(Collectors.joining()); // MagmaCube - decompile fix
   }
 }
diff --git a/src/main/java/net/minecraft/client/Minecraft.java b/src/main/java/net/minecraft/client/Minecraft.java
index 988679e014044baebbfa742e6f79359650c59953..f8ebc3932c1d0462bb2d07eea932975e468c5f30 100644
--- a/src/main/java/net/minecraft/client/Minecraft.java
+++ b/src/main/java/net/minecraft/client/Minecraft.java
@@ -593,7 +593,7 @@ public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements
     } 
     LoadingOverlay.registerTextures(this);
     List<PackResources> debug6 = this.resourcePackRepository.openAllSelected();
-    setOverlay((Overlay)new LoadingOverlay(this, this.resourceManager.createFullReload(Util.backgroundExecutor(), (Executor)this, RESOURCE_RELOAD_INITIAL_TASK, debug6), debug1 -> Util.ifElse(debug1, this::rollbackResourcePacks, ()), false));
+    setOverlay((Overlay)new LoadingOverlay(this, this.resourceManager.createFullReload(Util.backgroundExecutor(), (Executor)this, RESOURCE_RELOAD_INITIAL_TASK, debug6), debug12 -> Util.ifElse(debug12, this::rollbackResourcePacks, null), false)); // MagmaCube - decompile fix
   }
   
   public void updateTitle() {
@@ -628,7 +628,7 @@ public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements
   
   private void rollbackResourcePacks(Throwable debug1) {
     if (this.resourcePackRepository.getSelectedIds().size() > 1) {
-      Component debug2;
+      Component debug2 = null; // MagmaCube - decompile fix
       if (debug1 instanceof SimpleReloadableResourceManager.ResourcePackLoadingFailure) {
         TextComponent textComponent = new TextComponent(((SimpleReloadableResourceManager.ResourcePackLoadingFailure)debug1).getPack().getName());
       } else {
@@ -647,9 +647,11 @@ public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements
     this.options.incompatibleResourcePacks.clear();
     this.options.save();
     reloadResourcePacks().thenRun(() -> {
-          ToastComponent debug2 = getToasts();
-          SystemToast.addOrUpdate(debug2, SystemToast.SystemToastIds.PACK_LOAD_FAILURE, (Component)new TranslatableComponent("resourcePack.load_fail"), debug1);
-        });
+      // MagmaCube start - decompile fix
+      ToastComponent debug22 = getToasts();
+      SystemToast.addOrUpdate(debug22, SystemToast.SystemToastIds.PACK_LOAD_FAILURE, (Component) new TranslatableComponent("resourcePack.load_fail"), debug2);
+    });
+    // MagmaCube end - decompile fix
   }
   
   public void run() {
@@ -697,16 +699,19 @@ public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements
   }
   
   private void createSearchTrees() {
-    ReloadableSearchTree<ItemStack> debug1 = new ReloadableSearchTree(debug0 -> debug0.getTooltipLines(null, (TooltipFlag)TooltipFlag.Default.NORMAL).stream().map(()).filter(()), debug0 -> Stream.of(Registry.ITEM.getKey(debug0.getItem())));
-    ReloadableIdSearchTree<ItemStack> debug2 = new ReloadableIdSearchTree(debug0 -> ItemTags.getAllTags().getMatchingTags(debug0.getItem()).stream());
+    ReloadableSearchTree<ItemStack> debug1 = new ReloadableSearchTree<ItemStack>(debug0 -> debug0.getTooltipLines(null, (TooltipFlag)TooltipFlag.Default.NORMAL).stream().map(Component::getString), debug0 -> Stream.of(Registry.ITEM.getKey(debug0.getItem()))); // MagmaCube - decompile fix
+    ReloadableIdSearchTree<ItemStack> debug2 = new ReloadableIdSearchTree<>(debug0 -> ItemTags.getAllTags().getMatchingTags(debug0.getItem()).stream()); // MagmaCube - decompile fix
     NonNullList<ItemStack> debug3 = NonNullList.create();
     for (Item debug5 : Registry.ITEM)
-      debug5.fillItemCategory(CreativeModeTab.TAB_SEARCH, debug3); 
-    debug3.forEach(debug2 -> {
-          debug0.add(debug2);
-          debug1.add(debug2);
+      debug5.fillItemCategory(CreativeModeTab.TAB_SEARCH, debug3);
+    // MagmaCube start - decompile fix
+    debug3.forEach(debug22 -> {
+          debug2.add(debug22);
+          debug1.add(debug22);
+          // MagmaCube end - decompile fix
         });
-    ReloadableSearchTree<RecipeCollection> debug4 = new ReloadableSearchTree(debug0 -> debug0.getRecipes().stream().flatMap(()).map(()).filter(()), debug0 -> debug0.getRecipes().stream().map(()));
+    ReloadableSearchTree<RecipeCollection> debug4 = new ReloadableSearchTree<>(debug0 -> debug0.getRecipes().stream().map(recipe -> recipe.getGroup()), debug0 -> debug0.getRecipes().stream().map(Recipe::getId)); // MagmaCube - decompile fix - original broken code below
+    // ReloadableSearchTree<RecipeCollection> debug4 = new ReloadableSearchTree(debug0 -> debug0.getRecipes().stream().flatMap(()).map(()).filter(()), debug0 -> debug0.getRecipes().stream().map(()));
     this.searchRegistry.register(SearchRegistry.CREATIVE_NAMES, (MutableSearchTree)debug1);
     this.searchRegistry.register(SearchRegistry.CREATIVE_TAGS, (MutableSearchTree)debug2);
     this.searchRegistry.register(SearchRegistry.RECIPE_COLLECTIONS, (MutableSearchTree)debug4);
@@ -773,7 +778,7 @@ public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements
     } 
     this.resourcePackRepository.reload();
     List<PackResources> debug2 = this.resourcePackRepository.openAllSelected();
-    setOverlay((Overlay)new LoadingOverlay(this, this.resourceManager.createFullReload(Util.backgroundExecutor(), (Executor)this, RESOURCE_RELOAD_INITIAL_TASK, debug2), debug2 -> Util.ifElse(debug2, this::rollbackResourcePacks, ()), true));
+    setOverlay((Overlay)new LoadingOverlay(this, this.resourceManager.createFullReload(Util.backgroundExecutor(), (Executor)this, RESOURCE_RELOAD_INITIAL_TASK, debug2), debug22 -> Util.ifElse(debug22, this::rollbackResourcePacks, null), true)); // MagmaCube - decompile fix
     return debug1;
   }
   
@@ -834,8 +839,8 @@ public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements
   }
   
   public void setScreen(@Nullable Screen debug1) {
-    TitleScreen titleScreen;
-    DeathScreen deathScreen;
+    Screen titleScreen = null; // MagmaCube
+    Screen deathScreen = null; // MagmaCube
     if (this.screen != null)
       this.screen.removed(); 
     if (debug1 == null && this.level == null) {
@@ -921,7 +926,7 @@ public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements
     if (this.pendingReload != null && !(this.overlay instanceof LoadingOverlay)) {
       CompletableFuture<Void> completableFuture = this.pendingReload;
       this.pendingReload = null;
-      reloadResourcePacks().thenRun(() -> debug0.complete(null));
+      reloadResourcePacks().thenRun(() -> completableFuture.complete(null));
     } 
     Runnable debug4;
     while ((debug4 = this.progressTasks.poll()) != null)
@@ -1232,7 +1237,7 @@ public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements
     } 
     if (this.player.isHandsBusy())
       return; 
-    switch (null.$SwitchMap$net$minecraft$world$phys$HitResult$Type[this.hitResult.getType().ordinal()]) {
+    switch (this.hitResult.getType().ordinal()) { // MagmaCube - decompile fix
       case 1:
         this.gameMode.attack((Player)this.player, ((EntityHitResult)this.hitResult).getEntity());
         break;
@@ -1269,7 +1274,7 @@ public class Minecraft extends ReentrantBlockableEventLoop<Runnable> implements
         BlockHitResult debug9;
         int debug10;
         InteractionResult debug11;
-        switch (null.$SwitchMap$net$minecraft$world$phys$HitResult$Type[this.hitResult.getType().ordinal()]) {
+        switch (this.hitResult.getType().ordinal()) {
           case 1:
             debug6 = (EntityHitResult)this.hitResult;
             debug7 = debug6.getEntity();
diff --git a/src/main/java/net/minecraft/client/gui/components/Button.java b/src/main/java/net/minecraft/client/gui/components/Button.java
index c1bf279b9b72adf473d5b4818a0363ffb8da3545..2ff8fc7ee5fba80b4ed22f01faac02272dea05f2 100644
--- a/src/main/java/net/minecraft/client/gui/components/Button.java
+++ b/src/main/java/net/minecraft/client/gui/components/Button.java
@@ -35,4 +35,14 @@ public class Button extends AbstractButton {
   public void renderToolTip(PoseStack debug1, int debug2, int debug3) {
     this.onTooltip.onTooltip(this, debug1, debug2, debug3);
   }
+
+  // MagmaCube start - decompile fix
+  public static interface OnTooltip {
+    void onTooltip(Button param1Button, PoseStack param1PoseStack, int param1Int1, int param1Int2);
+  }
+
+  public static interface OnPress {
+    void onPress(Button param1Button);
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/client/gui/components/ChatComponent.java b/src/main/java/net/minecraft/client/gui/components/ChatComponent.java
index 55e527c2a070ef139ad82583c785120b178e49b3..0abf08cff861e4dc858dfe442cdf74367bba09cb 100644
--- a/src/main/java/net/minecraft/client/gui/components/ChatComponent.java
+++ b/src/main/java/net/minecraft/client/gui/components/ChatComponent.java
@@ -248,8 +248,8 @@ public class ChatComponent extends GuiComponent {
   }
   
   private void removeById(int debug1) {
-    this.trimmedMessages.removeIf(debug1 -> (debug1.getId() == debug0));
-    this.allMessages.removeIf(debug1 -> (debug1.getId() == debug0));
+    this.trimmedMessages.removeIf(debug12 -> (debug12.getId() == debug1));
+    this.allMessages.removeIf(debug12 -> (debug12.getId() == debug1));
   }
   
   public int getWidth() {
diff --git a/src/main/java/net/minecraft/client/gui/components/toasts/SystemToast.java b/src/main/java/net/minecraft/client/gui/components/toasts/SystemToast.java
index 83dc1676fc7a6c4cd9536e46011c0dc89b2ec79c..68a4dcceb32159b9b2bd53f6fb9a2f56732d244e 100644
--- a/src/main/java/net/minecraft/client/gui/components/toasts/SystemToast.java
+++ b/src/main/java/net/minecraft/client/gui/components/toasts/SystemToast.java
@@ -100,6 +100,12 @@ public class SystemToast implements Toast {
   public SystemToastIds getToken() {
     return this.id;
   }
+
+  // MagmaCube start - decompile fix
+  public enum SystemToastIds {
+    TUTORIAL_HINT, NARRATOR_TOGGLE, WORLD_BACKUP, WORLD_GEN_SETTINGS_TRANSFER, PACK_LOAD_FAILURE, WORLD_ACCESS_FAILURE, PACK_COPY_FAILURE;
+  }
+  // MagmaCube end - decompile fix
   
   public static void add(ToastComponent debug0, SystemToastIds debug1, Component debug2, @Nullable Component debug3) {
     debug0.addToast(new SystemToast(debug1, debug2, debug3));
diff --git a/src/main/java/net/minecraft/client/gui/components/toasts/Toast.java b/src/main/java/net/minecraft/client/gui/components/toasts/Toast.java
index 516e21f0d304b4537889ec15bed39bc81e077f6f..db05252f29d74f103b5ea628030a423e8a931d92 100644
--- a/src/main/java/net/minecraft/client/gui/components/toasts/Toast.java
+++ b/src/main/java/net/minecraft/client/gui/components/toasts/Toast.java
@@ -1,7 +1,12 @@
 package net.minecraft.client.gui.components.toasts;
 
 import com.mojang.blaze3d.vertex.PoseStack;
+import net.minecraft.client.resources.sounds.SimpleSoundInstance;
+import net.minecraft.client.resources.sounds.SoundInstance;
+import net.minecraft.client.sounds.SoundManager;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.sounds.SoundEvent;
+import net.minecraft.sounds.SoundEvents;
 
 public interface Toast {
   public static final ResourceLocation TEXTURE = new ResourceLocation("textures/gui/toasts.png");
@@ -21,4 +26,21 @@ public interface Toast {
   default int height() {
     return 32;
   }
+
+  // MagmaCube start - decompile fix
+  public enum Visibility {
+    SHOW(SoundEvents.UI_TOAST_IN),
+    HIDE(SoundEvents.UI_TOAST_OUT);
+
+    private final SoundEvent soundEvent;
+
+    Visibility(SoundEvent debug3) {
+      this.soundEvent = debug3;
+    }
+
+    public void playSound(SoundManager debug1) {
+      debug1.play((SoundInstance) SimpleSoundInstance.forUI(this.soundEvent, 1.0F, 1.0F));
+    }
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/client/main/GameConfig.java b/src/main/java/net/minecraft/client/main/GameConfig.java
index cef5261bb467350a72c7588858f607333f29bd6b..c9e12ea19f0079b11903c4bb25ef602f4d3668eb 100644
--- a/src/main/java/net/minecraft/client/main/GameConfig.java
+++ b/src/main/java/net/minecraft/client/main/GameConfig.java
@@ -1,6 +1,14 @@
 package net.minecraft.client.main;
 
+import com.mojang.authlib.properties.PropertyMap;
 import com.mojang.blaze3d.platform.DisplayData;
+import net.minecraft.client.User;
+import net.minecraft.client.resources.AssetIndex;
+import net.minecraft.client.resources.DirectAssetIndex;
+
+import javax.annotation.Nullable;
+import java.io.File;
+import java.net.Proxy;
 
 public class GameConfig {
   public final UserData user;
@@ -20,4 +28,75 @@ public class GameConfig {
     this.game = debug4;
     this.server = debug5;
   }
+
+  public static class GameData {
+    public final boolean demo;
+
+    public final String launchVersion;
+
+    public final String versionType;
+
+    public final boolean disableMultiplayer;
+
+    public final boolean disableChat;
+
+    public GameData(boolean debug1, String debug2, String debug3, boolean debug4, boolean debug5) {
+      this.demo = debug1;
+      this.launchVersion = debug2;
+      this.versionType = debug3;
+      this.disableMultiplayer = debug4;
+      this.disableChat = debug5;
+    }
+  }
+
+  public static class UserData {
+    public final User user;
+
+    public final PropertyMap userProperties;
+
+    public final PropertyMap profileProperties;
+
+    public final Proxy proxy;
+
+    public UserData(User debug1, PropertyMap debug2, PropertyMap debug3, Proxy debug4) {
+      this.user = debug1;
+      this.userProperties = debug2;
+      this.profileProperties = debug3;
+      this.proxy = debug4;
+    }
+  }
+
+  public static class FolderData {
+    public final File gameDirectory;
+
+    public final File resourcePackDirectory;
+
+    public final File assetDirectory;
+
+    @Nullable
+    public final String assetIndex;
+
+    public FolderData(File debug1, File debug2, File debug3, @Nullable String debug4) {
+      this.gameDirectory = debug1;
+      this.resourcePackDirectory = debug2;
+      this.assetDirectory = debug3;
+      this.assetIndex = debug4;
+    }
+
+    public AssetIndex getAssetIndex() {
+      return (this.assetIndex == null) ? (AssetIndex)new DirectAssetIndex(this.assetDirectory) : new AssetIndex(this.assetDirectory, this.assetIndex);
+    }
+  }
+
+  public static class ServerData {
+    @Nullable
+    public final String hostname;
+
+    public final int port;
+
+    public ServerData(@Nullable String debug1, int debug2) {
+      this.hostname = debug1;
+      this.port = debug2;
+    }
+  }
 }
diff --git a/src/main/java/net/minecraft/client/main/Main.java b/src/main/java/net/minecraft/client/main/Main.java
index 5f82d980c16a009d7dbcab82499ed366aa802b21..6ceea121a10757765072190f629b838bca14912f 100644
--- a/src/main/java/net/minecraft/client/main/Main.java
+++ b/src/main/java/net/minecraft/client/main/Main.java
@@ -9,6 +9,7 @@ import com.mojang.blaze3d.systems.RenderSystem;
 import java.io.File;
 import java.net.Authenticator;
 import java.net.InetSocketAddress;
+import java.net.PasswordAuthentication; // MagmaCube
 import java.net.Proxy;
 import java.util.List;
 import java.util.OptionalInt;
@@ -38,7 +39,7 @@ public class Main {
   
   public static void main(String[] debug0) {
     Minecraft debug56;
-    Object debug57;
+    Thread debug57; // MagmaCube - decompile fix
     OptionParser debug1 = new OptionParser();
     debug1.allowsUnrecognizedOptions();
     debug1.accepts("demo");
@@ -46,29 +47,31 @@ public class Main {
     debug1.accepts("disableChat");
     debug1.accepts("fullscreen");
     debug1.accepts("checkGlErrors");
+    // MagmaCube start - decompile fix
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec1 = debug1.accepts("server").withRequiredArg();
-    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec2 = debug1.accepts("port").withRequiredArg().ofType(Integer.class).defaultsTo(Integer.valueOf(25565), (Object[])new Integer[0]);
-    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec3 = debug1.accepts("gameDir").withRequiredArg().ofType(File.class).defaultsTo(new File("."), (Object[])new File[0]);
+    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec2 = debug1.accepts("port").withRequiredArg().ofType(Integer.class).defaultsTo(25565);
+    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec3 = debug1.accepts("gameDir").withRequiredArg().ofType(File.class).defaultsTo(new File("."));
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec4 = debug1.accepts("assetsDir").withRequiredArg().ofType(File.class);
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec5 = debug1.accepts("resourcePackDir").withRequiredArg().ofType(File.class);
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec6 = debug1.accepts("dataPackDir").withRequiredArg().ofType(File.class);
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec7 = debug1.accepts("proxyHost").withRequiredArg();
-    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec8 = debug1.accepts("proxyPort").withRequiredArg().defaultsTo("8080", (Object[])new String[0]).ofType(Integer.class);
+    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec8 = debug1.accepts("proxyPort").withRequiredArg().defaultsTo("8080").ofType(Integer.class);
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec9 = debug1.accepts("proxyUser").withRequiredArg();
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec10 = debug1.accepts("proxyPass").withRequiredArg();
-    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec11 = debug1.accepts("username").withRequiredArg().defaultsTo("Player" + (Util.getMillis() % 1000L), (Object[])new String[0]);
+    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec11 = debug1.accepts("username").withRequiredArg().defaultsTo("Player" + (Util.getMillis() % 1000L));
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec12 = debug1.accepts("uuid").withRequiredArg();
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec13 = debug1.accepts("accessToken").withRequiredArg().required();
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec14 = debug1.accepts("version").withRequiredArg().required();
-    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec15 = debug1.accepts("width").withRequiredArg().ofType(Integer.class).defaultsTo(Integer.valueOf(854), (Object[])new Integer[0]);
-    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec16 = debug1.accepts("height").withRequiredArg().ofType(Integer.class).defaultsTo(Integer.valueOf(480), (Object[])new Integer[0]);
+    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec15 = debug1.accepts("width").withRequiredArg().ofType(Integer.class).defaultsTo(854);
+    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec16 = debug1.accepts("height").withRequiredArg().ofType(Integer.class).defaultsTo(480);
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec17 = debug1.accepts("fullscreenWidth").withRequiredArg().ofType(Integer.class);
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec18 = debug1.accepts("fullscreenHeight").withRequiredArg().ofType(Integer.class);
-    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec19 = debug1.accepts("userProperties").withRequiredArg().defaultsTo("{}", (Object[])new String[0]);
-    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec20 = debug1.accepts("profileProperties").withRequiredArg().defaultsTo("{}", (Object[])new String[0]);
+    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec19 = debug1.accepts("userProperties").withRequiredArg().defaultsTo("{}");
+    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec20 = debug1.accepts("profileProperties").withRequiredArg().defaultsTo("{}");
     ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec21 = debug1.accepts("assetIndex").withRequiredArg();
-    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec22 = debug1.accepts("userType").withRequiredArg().defaultsTo("legacy", (Object[])new String[0]);
-    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec23 = debug1.accepts("versionType").withRequiredArg().defaultsTo("release", (Object[])new String[0]);
+    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec22 = debug1.accepts("userType").withRequiredArg().defaultsTo("legacy");
+    ArgumentAcceptingOptionSpec argumentAcceptingOptionSpec23 = debug1.accepts("versionType").withRequiredArg().defaultsTo("release");
+    // MagmaCube end - decompile fix
     NonOptionArgumentSpec nonOptionArgumentSpec = debug1.nonOptions();
     OptionSet debug26 = debug1.parse(debug0);
     List<String> debug27 = debug26.valuesOf((OptionSpec)nonOptionArgumentSpec);
@@ -83,7 +86,14 @@ public class Main {
     String debug30 = parseArgument(debug26, (OptionSpec<String>)argumentAcceptingOptionSpec9);
     String debug31 = parseArgument(debug26, (OptionSpec<String>)argumentAcceptingOptionSpec10);
     if (!debug29.equals(Proxy.NO_PROXY) && stringHasValue(debug30) && stringHasValue(debug31))
-      Authenticator.setDefault((Authenticator)new Object(debug30, debug31)); 
+      // MagmaCube start - decompile fix
+      Authenticator.setDefault(new Authenticator() {
+        @Override
+        protected PasswordAuthentication getPasswordAuthentication() {
+          return new PasswordAuthentication(debug30, debug31.toCharArray());
+        }
+      });
+    // MagmaCube end - decompile fix
     int debug32 = ((Integer)parseArgument(debug26, (OptionSpec<Integer>)argumentAcceptingOptionSpec15)).intValue();
     int debug33 = ((Integer)parseArgument(debug26, (OptionSpec<Integer>)argumentAcceptingOptionSpec16)).intValue();
     OptionalInt debug34 = ofNullable(parseArgument(debug26, (OptionSpec<Integer>)argumentAcceptingOptionSpec17));
@@ -110,15 +120,16 @@ public class Main {
     Util.startTimerHackThread();
     User debug52 = new User((String)argumentAcceptingOptionSpec11.value(debug26), debug48, (String)argumentAcceptingOptionSpec13.value(debug26), (String)argumentAcceptingOptionSpec22.value(debug26));
     GameConfig debug53 = new GameConfig(new GameConfig.UserData(debug52, debug42, debug43, debug29), new DisplayData(debug32, debug33, debug34, debug35, debug36), new GameConfig.FolderData(debug45, debug47, debug46, debug49), new GameConfig.GameData(debug37, debug40, debug44, debug38, debug39), new GameConfig.ServerData(debug50, debug51.intValue()));
-    Object object1 = new Object("Client Shutdown Thread");
+    Thread object1 = new Thread("Client Shutdown Thread"); // MagmaCube - decompile fix
     object1.setUncaughtExceptionHandler((Thread.UncaughtExceptionHandler)new DefaultUncaughtExceptionHandler(LOGGER));
     Runtime.getRuntime().addShutdownHook((Thread)object1);
     RenderPipeline debug55 = new RenderPipeline();
+    Minecraft minecraft; // MagmaCube - OBFHelper
     try {
       Thread.currentThread().setName("Render thread");
       RenderSystem.initRenderThread();
       RenderSystem.beginInitialization();
-      debug56 = new Minecraft(debug53);
+      debug56 = minecraft = new Minecraft(debug53);
       RenderSystem.finishInitialization();
     } catch (SilentInitException silentInitException) {
       LOGGER.warn("Failed to create window: ", (Throwable)silentInitException);
@@ -131,7 +142,19 @@ public class Main {
       return;
     } 
     if (debug56.renderOnThread()) {
-      debug57 = new Object("Game thread", debug56);
+      // MagmaCube start - decompile fix
+      debug57 = new Thread("Game thread") {
+        @Override
+        public void run() {
+          try {
+            RenderSystem.initGameThread(true);
+            minecraft.run();
+          } catch (Throwable debug1) {
+            Main.LOGGER.error("Exception in client thread", debug1);
+          }
+        }
+      };
+      // MagmaCube end - decompile fix
       debug57.start();
       while (debug56.isRunning());
     } else {
diff --git a/src/main/java/net/minecraft/client/multiplayer/ClientLevel.java b/src/main/java/net/minecraft/client/multiplayer/ClientLevel.java
index 29752afa4a7ff34bc68d766029ce126a74324990..dc34bcf2b7636752ceda06ed19f3a6ecd8d35c47 100644
--- a/src/main/java/net/minecraft/client/multiplayer/ClientLevel.java
+++ b/src/main/java/net/minecraft/client/multiplayer/ClientLevel.java
@@ -46,6 +46,7 @@ import net.minecraft.tags.Tag;
 import net.minecraft.tags.TagContainer;
 import net.minecraft.util.Mth;
 import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.world.Difficulty;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
@@ -189,7 +190,7 @@ public class ClientLevel extends Level {
     debug1.xRotO = debug1.xRot;
     if (debug1.inChunk || debug1.isSpectator()) {
       debug1.tickCount++;
-      getProfiler().push(() -> Registry.ENTITY_TYPE.getKey(debug0.getType()).toString());
+      getProfiler().push(() -> Registry.ENTITY_TYPE.getKey(debug1.getType()).toString());
       debug1.tick();
       getProfiler().pop();
     } 
@@ -246,7 +247,7 @@ public class ClientLevel extends Level {
   }
   
   public void onChunkLoaded(int debug1, int debug2) {
-    this.tintCaches.forEach((debug2, debug3) -> debug3.invalidateForChunk(debug0, debug1));
+    this.tintCaches.forEach((debug22, debug3) -> debug3.invalidateForChunk(debug2, debug1));
   }
   
   public void clearTintCaches() {
@@ -353,9 +354,9 @@ public class ClientLevel extends Level {
     if (debug6 && debug11.is(Blocks.BARRIER))
       addParticle((ParticleOptions)ParticleTypes.BARRIER, debug8 + 0.5D, debug9 + 0.5D, debug10 + 0.5D, 0.0D, 0.0D, 0.0D); 
     if (!debug11.isCollisionShapeFullBlock((BlockGetter)this, (BlockPos)debug7))
-      getBiome((BlockPos)debug7).getAmbientParticle().ifPresent(debug2 -> {
-            if (debug2.canSpawn(this.random))
-              addParticle(debug2.getOptions(), debug1.getX() + this.random.nextDouble(), debug1.getY() + this.random.nextDouble(), debug1.getZ() + this.random.nextDouble(), 0.0D, 0.0D, 0.0D); 
+      getBiome((BlockPos)debug7).getAmbientParticle().ifPresent(debug22 -> {
+            if (debug22.canSpawn(this.random))
+              addParticle(debug22.getOptions(), debug7.getX() + this.random.nextDouble(), debug7.getY() + this.random.nextDouble(), debug7.getZ() + this.random.nextDouble(), 0.0D, 0.0D, 0.0D);
           }); 
   }
   
@@ -454,11 +455,11 @@ public class ClientLevel extends Level {
   }
   
   public TickList<Block> getBlockTicks() {
-    return (TickList<Block>)EmptyTickList.empty();
+    return (TickList<Block>)(Object)EmptyTickList.empty(); // MagmaCube - decompile fix
   }
   
   public TickList<Fluid> getLiquidTicks() {
-    return (TickList<Fluid>)EmptyTickList.empty();
+    return (TickList<Fluid>)(Object)EmptyTickList.empty(); // MagmaCube - decompile fix
   }
   
   public ClientChunkCache getChunkSource() {
@@ -646,7 +647,7 @@ public class ClientLevel extends Level {
     boolean debug3 = effects().constantAmbientLight();
     if (!debug2)
       return debug3 ? 0.9F : 1.0F; 
-    switch (null.$SwitchMap$net$minecraft$core$Direction[debug1.ordinal()]) {
+    switch (debug1.ordinal()) { // MagmaCube - decompile fix
       case 1:
         return debug3 ? 0.9F : 0.5F;
       case 2:
@@ -708,4 +709,146 @@ public class ClientLevel extends Level {
   public ClientLevelData getLevelData() {
     return this.clientLevelData;
   }
+
+  // MagmaCube start - decompile fix
+  public static class ClientLevelData implements WritableLevelData {
+    private final boolean hardcore;
+
+    private final GameRules gameRules;
+
+    private final boolean isFlat;
+
+    private int xSpawn;
+
+    private int ySpawn;
+
+    private int zSpawn;
+
+    private float spawnAngle;
+
+    private long gameTime;
+
+    private long dayTime;
+
+    private boolean raining;
+
+    private Difficulty difficulty;
+
+    private boolean difficultyLocked;
+
+    public ClientLevelData(Difficulty debug1, boolean debug2, boolean debug3) {
+      this.difficulty = debug1;
+      this.hardcore = debug2;
+      this.isFlat = debug3;
+      this.gameRules = new GameRules();
+    }
+
+    public int getXSpawn() {
+      return this.xSpawn;
+    }
+
+    public int getYSpawn() {
+      return this.ySpawn;
+    }
+
+    public int getZSpawn() {
+      return this.zSpawn;
+    }
+
+    public float getSpawnAngle() {
+      return this.spawnAngle;
+    }
+
+    public long getGameTime() {
+      return this.gameTime;
+    }
+
+    public long getDayTime() {
+      return this.dayTime;
+    }
+
+    public void setXSpawn(int debug1) {
+      this.xSpawn = debug1;
+    }
+
+    public void setYSpawn(int debug1) {
+      this.ySpawn = debug1;
+    }
+
+    public void setZSpawn(int debug1) {
+      this.zSpawn = debug1;
+    }
+
+    public void setSpawnAngle(float debug1) {
+      this.spawnAngle = debug1;
+    }
+
+    public void setGameTime(long debug1) {
+      this.gameTime = debug1;
+    }
+
+    public void setDayTime(long debug1) {
+      this.dayTime = debug1;
+    }
+
+    public void setSpawn(BlockPos debug1, float debug2) {
+      this.xSpawn = debug1.getX();
+      this.ySpawn = debug1.getY();
+      this.zSpawn = debug1.getZ();
+      this.spawnAngle = debug2;
+    }
+
+    public boolean isThundering() {
+      return false;
+    }
+
+    public boolean isRaining() {
+      return this.raining;
+    }
+
+    public void setRaining(boolean debug1) {
+      this.raining = debug1;
+    }
+
+    public boolean isHardcore() {
+      return this.hardcore;
+    }
+
+    public GameRules getGameRules() {
+      return this.gameRules;
+    }
+
+    public Difficulty getDifficulty() {
+      return this.difficulty;
+    }
+
+    public boolean isDifficultyLocked() {
+      return this.difficultyLocked;
+    }
+
+    public void fillCrashReportCategory(CrashReportCategory debug1) {
+      WritableLevelData.super.fillCrashReportCategory(debug1);
+    }
+
+    public void setDifficulty(Difficulty debug1) {
+      this.difficulty = debug1;
+    }
+
+    public void setDifficultyLocked(boolean debug1) {
+      this.difficultyLocked = debug1;
+    }
+
+    public double getHorizonHeight() {
+      if (this.isFlat)
+        return 0.0D;
+      return 63.0D;
+    }
+
+    public double getClearColorScale() {
+      if (this.isFlat)
+        return 1.0D;
+      return 0.03125D;
+    }
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/client/particle/FireworkParticles.java b/src/main/java/net/minecraft/client/particle/FireworkParticles.java
index af998185be82dcbae50af90a2676e389a7232c0e..1dfd533bdcabb9eac573c3c76792fff651de4414 100644
--- a/src/main/java/net/minecraft/client/particle/FireworkParticles.java
+++ b/src/main/java/net/minecraft/client/particle/FireworkParticles.java
@@ -1,3 +1,310 @@
 package net.minecraft.client.particle;
 
-public class FireworkParticles {}
+import com.mojang.blaze3d.vertex.VertexConsumer;
+import net.minecraft.Util;
+import net.minecraft.client.Camera;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.core.particles.ParticleOptions;
+import net.minecraft.core.particles.ParticleTypes;
+import net.minecraft.core.particles.SimpleParticleType;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.sounds.SoundEvent;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.sounds.SoundSource;
+import net.minecraft.util.Mth;
+import net.minecraft.world.item.DyeColor;
+import net.minecraft.world.item.FireworkRocketItem;
+
+import javax.annotation.Nullable;
+
+public class FireworkParticles {
+    // MagmaCube start - decompile fix
+    public static class Starter extends NoRenderParticle {
+        private int life;
+
+        private final ParticleEngine engine;
+
+        private ListTag explosions;
+
+        private boolean twinkleDelay;
+
+        public Starter(ClientLevel debug1, double debug2, double debug4, double debug6, double debug8, double debug10, double debug12, ParticleEngine debug14, @Nullable CompoundTag debug15) {
+            super(debug1, debug2, debug4, debug6);
+            this.xd = debug8;
+            this.yd = debug10;
+            this.zd = debug12;
+            this.engine = debug14;
+            this.lifetime = 8;
+            if (debug15 != null) {
+                this.explosions = debug15.getList("Explosions", 10);
+                if (this.explosions.isEmpty()) {
+                    this.explosions = null;
+                } else {
+                    this.lifetime = this.explosions.size() * 2 - 1;
+                    for (int debug16 = 0; debug16 < this.explosions.size(); debug16++) {
+                        CompoundTag debug17 = this.explosions.getCompound(debug16);
+                        if (debug17.getBoolean("Flicker")) {
+                            this.twinkleDelay = true;
+                            this.lifetime += 15;
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+
+        public void tick() {
+            if (this.life == 0 && this.explosions != null) {
+                SoundEvent debug3;
+                boolean debug1 = isFarAwayFromCamera();
+                boolean debug2 = false;
+                if (this.explosions.size() >= 3) {
+                    debug2 = true;
+                } else {
+                    for (int i = 0; i < this.explosions.size(); i++) {
+                        CompoundTag debug4 = this.explosions.getCompound(i);
+                        if (FireworkRocketItem.Shape.byId(debug4.getByte("Type")) == FireworkRocketItem.Shape.LARGE_BALL) {
+                            debug2 = true;
+                            break;
+                        }
+                    }
+                }
+                if (debug2) {
+                    debug3 = debug1 ? SoundEvents.FIREWORK_ROCKET_LARGE_BLAST_FAR : SoundEvents.FIREWORK_ROCKET_LARGE_BLAST;
+                } else {
+                    debug3 = debug1 ? SoundEvents.FIREWORK_ROCKET_BLAST_FAR : SoundEvents.FIREWORK_ROCKET_BLAST;
+                }
+                this.level.playLocalSound(this.x, this.y, this.z, debug3, SoundSource.AMBIENT, 20.0F, 0.95F + this.random.nextFloat() * 0.1F, true);
+            }
+            if (this.life % 2 == 0 && this.explosions != null && this.life / 2 < this.explosions.size()) {
+                int debug1 = this.life / 2;
+                CompoundTag debug2 = this.explosions.getCompound(debug1);
+                FireworkRocketItem.Shape debug3 = FireworkRocketItem.Shape.byId(debug2.getByte("Type"));
+                boolean debug4 = debug2.getBoolean("Trail");
+                boolean debug5 = debug2.getBoolean("Flicker");
+                int[] debug6 = debug2.getIntArray("Colors");
+                int[] debug7 = debug2.getIntArray("FadeColors");
+                if (debug6.length == 0)
+                    debug6 = new int[] { DyeColor.BLACK.getFireworkColor() };
+                switch (debug3) {
+                    default:
+                        createParticleBall(0.25D, 2, debug6, debug7, debug4, debug5);
+                        break;
+                    case LARGE_BALL:
+                        createParticleBall(0.5D, 4, debug6, debug7, debug4, debug5);
+                        break;
+                    case STAR:
+                        createParticleShape(0.5D, new double[][] { { 0.0D, 1.0D }, { 0.3455D, 0.309D }, { 0.9511D, 0.309D }, { 0.3795918367346939D, -0.12653061224489795D }, { 0.6122448979591837D, -0.8040816326530612D }, { 0.0D, -0.35918367346938773D },  }, debug6, debug7, debug4, debug5, false);
+                        break;
+                    case CREEPER:
+                        createParticleShape(0.5D, new double[][] {
+                                { 0.0D, 0.2D }, { 0.2D, 0.2D }, { 0.2D, 0.6D }, { 0.6D, 0.6D }, { 0.6D, 0.2D }, { 0.2D, 0.2D }, { 0.2D, 0.0D }, { 0.4D, 0.0D }, { 0.4D, -0.6D }, { 0.2D, -0.6D },
+                                { 0.2D, -0.4D }, { 0.0D, -0.4D },  }, debug6, debug7, debug4, debug5, true);
+                        break;
+                    case BURST:
+                        createParticleBurst(debug6, debug7, debug4, debug5);
+                        break;
+                }
+                int debug8 = debug6[0];
+                float debug9 = ((debug8 & 0xFF0000) >> 16) / 255.0F;
+                float debug10 = ((debug8 & 0xFF00) >> 8) / 255.0F;
+                float debug11 = ((debug8 & 0xFF) >> 0) / 255.0F;
+                Particle debug12 = this.engine.createParticle((ParticleOptions)ParticleTypes.FLASH, this.x, this.y, this.z, 0.0D, 0.0D, 0.0D);
+                debug12.setColor(debug9, debug10, debug11);
+            }
+            this.life++;
+            if (this.life > this.lifetime) {
+                if (this.twinkleDelay) {
+                    boolean debug1 = isFarAwayFromCamera();
+                    SoundEvent debug2 = debug1 ? SoundEvents.FIREWORK_ROCKET_TWINKLE_FAR : SoundEvents.FIREWORK_ROCKET_TWINKLE;
+                    this.level.playLocalSound(this.x, this.y, this.z, debug2, SoundSource.AMBIENT, 20.0F, 0.9F + this.random.nextFloat() * 0.15F, true);
+                }
+                remove();
+            }
+        }
+
+        private boolean isFarAwayFromCamera() {
+            Minecraft debug1 = Minecraft.getInstance();
+            return (debug1.gameRenderer.getMainCamera().getPosition().distanceToSqr(this.x, this.y, this.z) >= 256.0D);
+        }
+
+        private void createParticle(double debug1, double debug3, double debug5, double debug7, double debug9, double debug11, int[] debug13, int[] debug14, boolean debug15, boolean debug16) {
+            FireworkParticles.SparkParticle debug17 = (FireworkParticles.SparkParticle)this.engine.createParticle((ParticleOptions) ParticleTypes.FIREWORK, debug1, debug3, debug5, debug7, debug9, debug11);
+            debug17.setTrail(debug15);
+            debug17.setFlicker(debug16);
+            debug17.setAlpha(0.99F);
+            int debug18 = this.random.nextInt(debug13.length);
+            debug17.setColor(debug13[debug18]);
+            if (debug14.length > 0)
+                debug17.setFadeColor(Util.getRandom(debug14, this.random));
+        }
+
+        private void createParticleBall(double debug1, int debug3, int[] debug4, int[] debug5, boolean debug6, boolean debug7) {
+            double debug8 = this.x;
+            double debug10 = this.y;
+            double debug12 = this.z;
+            for (int debug14 = -debug3; debug14 <= debug3; debug14++) {
+                for (int debug15 = -debug3; debug15 <= debug3; debug15++) {
+                    for (int debug16 = -debug3; debug16 <= debug3; debug16++) {
+                        double debug17 = debug15 + (this.random.nextDouble() - this.random.nextDouble()) * 0.5D;
+                        double debug19 = debug14 + (this.random.nextDouble() - this.random.nextDouble()) * 0.5D;
+                        double debug21 = debug16 + (this.random.nextDouble() - this.random.nextDouble()) * 0.5D;
+                        double debug23 = Mth.sqrt(debug17 * debug17 + debug19 * debug19 + debug21 * debug21) / debug1 + this.random.nextGaussian() * 0.05D;
+                        createParticle(debug8, debug10, debug12, debug17 / debug23, debug19 / debug23, debug21 / debug23, debug4, debug5, debug6, debug7);
+                        if (debug14 != -debug3 && debug14 != debug3 && debug15 != -debug3 && debug15 != debug3)
+                            debug16 += debug3 * 2 - 1;
+                    }
+                }
+            }
+        }
+
+        private void createParticleShape(double debug1, double[][] debug3, int[] debug4, int[] debug5, boolean debug6, boolean debug7, boolean debug8) {
+            double debug9 = debug3[0][0];
+            double debug11 = debug3[0][1];
+            createParticle(this.x, this.y, this.z, debug9 * debug1, debug11 * debug1, 0.0D, debug4, debug5, debug6, debug7);
+            float debug13 = this.random.nextFloat() * 3.1415927F;
+            double debug14 = debug8 ? 0.034D : 0.34D;
+            for (int debug16 = 0; debug16 < 3; debug16++) {
+                double debug17 = debug13 + (debug16 * 3.1415927F) * debug14;
+                double debug19 = debug9;
+                double debug21 = debug11;
+                for (int debug23 = 1; debug23 < debug3.length; debug23++) {
+                    double debug24 = debug3[debug23][0];
+                    double debug26 = debug3[debug23][1];
+                    double debug28;
+                    for (debug28 = 0.25D; debug28 <= 1.0D; debug28 += 0.25D) {
+                        double debug30 = Mth.lerp(debug28, debug19, debug24) * debug1;
+                        double debug32 = Mth.lerp(debug28, debug21, debug26) * debug1;
+                        double debug34 = debug30 * Math.sin(debug17);
+                        debug30 *= Math.cos(debug17);
+                        double debug36;
+                        for (debug36 = -1.0D; debug36 <= 1.0D; debug36 += 2.0D)
+                            createParticle(this.x, this.y, this.z, debug30 * debug36, debug32, debug34 * debug36, debug4, debug5, debug6, debug7);
+                    }
+                    debug19 = debug24;
+                    debug21 = debug26;
+                }
+            }
+        }
+
+        private void createParticleBurst(int[] debug1, int[] debug2, boolean debug3, boolean debug4) {
+            double debug5 = this.random.nextGaussian() * 0.05D;
+            double debug7 = this.random.nextGaussian() * 0.05D;
+            for (int debug9 = 0; debug9 < 70; debug9++) {
+                double debug10 = this.xd * 0.5D + this.random.nextGaussian() * 0.15D + debug5;
+                double debug12 = this.zd * 0.5D + this.random.nextGaussian() * 0.15D + debug7;
+                double debug14 = this.yd * 0.5D + this.random.nextDouble() * 0.5D;
+                createParticle(this.x, this.y, this.z, debug10, debug14, debug12, debug1, debug2, debug3, debug4);
+            }
+        }
+    }
+
+    static class SparkParticle extends SimpleAnimatedParticle {
+        private boolean trail;
+
+        private boolean flicker;
+
+        private final ParticleEngine engine;
+
+        private float fadeR;
+
+        private float fadeG;
+
+        private float fadeB;
+
+        private boolean hasFade;
+
+        private SparkParticle(ClientLevel debug1, double debug2, double debug4, double debug6, double debug8, double debug10, double debug12, ParticleEngine debug14, SpriteSet debug15) {
+            super(debug1, debug2, debug4, debug6, debug15, -0.004F);
+            this.xd = debug8;
+            this.yd = debug10;
+            this.zd = debug12;
+            this.engine = debug14;
+            this.quadSize *= 0.75F;
+            this.lifetime = 48 + this.random.nextInt(12);
+            setSpriteFromAge(debug15);
+        }
+
+        public void setTrail(boolean debug1) {
+            this.trail = debug1;
+        }
+
+        public void setFlicker(boolean debug1) {
+            this.flicker = debug1;
+        }
+
+        public void render(VertexConsumer debug1, Camera debug2, float debug3) {
+            if (!this.flicker || this.age < this.lifetime / 3 || (this.age + this.lifetime) / 3 % 2 == 0)
+                super.render(debug1, debug2, debug3);
+        }
+
+        public void tick() {
+            super.tick();
+            if (this.trail && this.age < this.lifetime / 2 && (this.age + this.lifetime) % 2 == 0) {
+                SparkParticle debug1 = new SparkParticle(this.level, this.x, this.y, this.z, 0.0D, 0.0D, 0.0D, this.engine, this.sprites);
+                debug1.setAlpha(0.99F);
+                debug1.setColor(this.rCol, this.gCol, this.bCol);
+                debug1.age = debug1.lifetime / 2;
+                if (this.hasFade) {
+                    debug1.hasFade = true;
+                    debug1.fadeR = this.fadeR;
+                    debug1.fadeG = this.fadeG;
+                    debug1.fadeB = this.fadeB;
+                }
+                debug1.flicker = this.flicker;
+                this.engine.add(debug1);
+            }
+        }
+    }
+
+    public static class OverlayParticle extends TextureSheetParticle {
+        private OverlayParticle(ClientLevel debug1, double debug2, double debug4, double debug6) {
+            super(debug1, debug2, debug4, debug6);
+            this.lifetime = 4;
+        }
+
+        public ParticleRenderType getRenderType() {
+            return ParticleRenderType.PARTICLE_SHEET_TRANSLUCENT;
+        }
+
+        public void render(VertexConsumer debug1, Camera debug2, float debug3) {
+            setAlpha(0.6F - (this.age + debug3 - 1.0F) * 0.25F * 0.5F);
+            super.render(debug1, debug2, debug3);
+        }
+
+        public float getQuadSize(float debug1) {
+            return 7.1F * Mth.sin((this.age + debug1 - 1.0F) * 0.25F * 3.1415927F);
+        }
+    }
+
+    public static class FlashProvider implements ParticleProvider<SimpleParticleType> {
+        private final SpriteSet sprite;
+
+        public FlashProvider(SpriteSet debug1) {
+            this.sprite = debug1;
+        }
+
+        public Particle createParticle(SimpleParticleType debug1, ClientLevel debug2, double debug3, double debug5, double debug7, double debug9, double debug11, double debug13) {
+            FireworkParticles.OverlayParticle debug15 = new FireworkParticles.OverlayParticle(debug2, debug3, debug5, debug7);
+            debug15.pickSprite(this.sprite);
+            return debug15;
+        }
+    }
+
+    public static class SparkProvider implements ParticleProvider<SimpleParticleType> {
+        private final SpriteSet sprites;
+
+        public SparkProvider(SpriteSet debug1) {
+            this.sprites = debug1;
+        }
+
+        public Particle createParticle(SimpleParticleType debug1, ClientLevel debug2, double debug3, double debug5, double debug7, double debug9, double debug11, double debug13) {
+            FireworkParticles.SparkParticle debug15 = new FireworkParticles.SparkParticle(debug2, debug3, debug5, debug7, debug9, debug11, debug13, (Minecraft.getInstance()).particleEngine, this.sprites);
+            debug15.setAlpha(0.99F);
+            return debug15;
+        }
+    }
+    // MagmaCube end - decompile fix
+}
diff --git a/src/main/java/net/minecraft/core/BlockPos.java b/src/main/java/net/minecraft/core/BlockPos.java
index 5dabb894e6d953eb670e84fd6699938f6ab46249..1663c9177b30194de0244148a65f55dd532b5999 100644
--- a/src/main/java/net/minecraft/core/BlockPos.java
+++ b/src/main/java/net/minecraft/core/BlockPos.java
@@ -1,5 +1,6 @@
 package net.minecraft.core;
 
+import com.google.common.collect.AbstractIterator;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.DataResult;
 import java.util.Iterator;
@@ -25,7 +26,7 @@ public class BlockPos extends Vec3i {
   public static final Codec<BlockPos> CODEC;
   
   static {
-    CODEC = Codec.INT_STREAM.comapFlatMap(debug0 -> Util.fixedSize(debug0, 3).map(()), debug0 -> IntStream.of(new int[] { debug0.getX(), debug0.getY(), debug0.getZ() })).stable();
+    CODEC = Codec.INT_STREAM.comapFlatMap(debug0 -> Util.fixedSize(debug0, 3).map(ints -> new BlockPos(ints[0], ints[1], ints[2])), debug0 -> IntStream.of(debug0.getX(), debug0.getY(), debug0.getZ())).stable(); // MagmaCube - decompile fix
   }
   
   private static final Logger LOGGER = LogManager.getLogger();
@@ -196,7 +197,7 @@ public class BlockPos extends Vec3i {
   }
   
   public BlockPos rotate(Rotation debug1) {
-    switch (null.$SwitchMap$net$minecraft$world$level$block$Rotation[debug1.ordinal()]) {
+    switch (debug1.ordinal()) { // MagmaCube - decompile fix
       default:
         return this;
       case 2:
@@ -220,21 +221,196 @@ public class BlockPos extends Vec3i {
   public MutableBlockPos mutable() {
     return new MutableBlockPos(getX(), getY(), getZ());
   }
-  
-  public static Iterable<BlockPos> randomBetweenClosed(Random debug0, int debug1, int debug2, int debug3, int debug4, int debug5, int debug6, int debug7) {
-    int debug8 = debug5 - debug2 + 1;
-    int debug9 = debug6 - debug3 + 1;
-    int debug10 = debug7 - debug4 + 1;
-    return () -> new Object(debug0, debug1, debug2, debug3, debug4, debug5, debug6, debug7);
+
+  // MagmaCube start - decompile fix
+  public static class MutableBlockPos extends BlockPos {
+    public MutableBlockPos() {
+      this(0, 0, 0);
+    }
+
+    public MutableBlockPos(int debug1, int debug2, int debug3) {
+      super(debug1, debug2, debug3);
+    }
+
+    public MutableBlockPos(double debug1, double debug3, double debug5) {
+      this(Mth.floor(debug1), Mth.floor(debug3), Mth.floor(debug5));
+    }
+
+    public BlockPos offset(double debug1, double debug3, double debug5) {
+      return super.offset(debug1, debug3, debug5).immutable();
+    }
+
+    public BlockPos offset(int debug1, int debug2, int debug3) {
+      return super.offset(debug1, debug2, debug3).immutable();
+    }
+
+    public BlockPos relative(Direction debug1, int debug2) {
+      return super.relative(debug1, debug2).immutable();
+    }
+
+    public BlockPos relative(Direction.Axis debug1, int debug2) {
+      return super.relative(debug1, debug2).immutable();
+    }
+
+    public BlockPos rotate(Rotation debug1) {
+      return super.rotate(debug1).immutable();
+    }
+
+    public MutableBlockPos set(int debug1, int debug2, int debug3) {
+      setX(debug1);
+      setY(debug2);
+      setZ(debug3);
+      return this;
+    }
+
+    public MutableBlockPos set(double debug1, double debug3, double debug5) {
+      return set(Mth.floor(debug1), Mth.floor(debug3), Mth.floor(debug5));
+    }
+
+    public MutableBlockPos set(Vec3i debug1) {
+      return set(debug1.getX(), debug1.getY(), debug1.getZ());
+    }
+
+    public MutableBlockPos set(long debug1) {
+      return set(getX(debug1), getY(debug1), getZ(debug1));
+    }
+
+    public MutableBlockPos set(AxisCycle debug1, int debug2, int debug3, int debug4) {
+      return set(debug1
+              .cycle(debug2, debug3, debug4, Direction.Axis.X), debug1
+              .cycle(debug2, debug3, debug4, Direction.Axis.Y), debug1
+              .cycle(debug2, debug3, debug4, Direction.Axis.Z));
+    }
+
+    public MutableBlockPos setWithOffset(Vec3i debug1, Direction debug2) {
+      return set(debug1.getX() + debug2.getStepX(), debug1.getY() + debug2.getStepY(), debug1.getZ() + debug2.getStepZ());
+    }
+
+    public MutableBlockPos setWithOffset(Vec3i debug1, int debug2, int debug3, int debug4) {
+      return set(debug1.getX() + debug2, debug1.getY() + debug3, debug1.getZ() + debug4);
+    }
+
+    public MutableBlockPos move(Direction debug1) {
+      return move(debug1, 1);
+    }
+
+    public MutableBlockPos move(Direction debug1, int debug2) {
+      return set(getX() + debug1.getStepX() * debug2, getY() + debug1.getStepY() * debug2, getZ() + debug1.getStepZ() * debug2);
+    }
+
+    public MutableBlockPos move(int debug1, int debug2, int debug3) {
+      return set(getX() + debug1, getY() + debug2, getZ() + debug3);
+    }
+
+    public MutableBlockPos move(Vec3i debug1) {
+      return set(getX() + debug1.getX(), getY() + debug1.getY(), getZ() + debug1.getZ());
+    }
+
+    public MutableBlockPos clamp(Direction.Axis debug1, int debug2, int debug3) {
+      switch (debug1) {
+        case X:
+          return set(Mth.clamp(getX(), debug2, debug3), getY(), getZ());
+        case Y:
+          return set(getX(), Mth.clamp(getY(), debug2, debug3), getZ());
+        case Z:
+          return set(getX(), getY(), Mth.clamp(getZ(), debug2, debug3));
+      }
+      throw new IllegalStateException("Unable to clamp axis " + debug1);
+    }
+
+    public void setX(int debug1) {
+      super.setX(debug1);
+    }
+
+    public void setY(int debug1) {
+      super.setY(debug1);
+    }
+
+    public void setZ(int debug1) {
+      super.setZ(debug1);
+    }
+
+    public BlockPos immutable() {
+      return new BlockPos(this);
+    }
   }
   
-  public static Iterable<BlockPos> withinManhattan(BlockPos debug0, int debug1, int debug2, int debug3) {
-    int debug4 = debug1 + debug2 + debug3;
-    int debug5 = debug0.getX();
-    int debug6 = debug0.getY();
-    int debug7 = debug0.getZ();
-    return () -> new Object(debug0, debug1, debug2, debug3, debug4, debug5, debug6);
+  public static Iterable<BlockPos> randomBetweenClosed(Random random, int minX, int limit, int width, int minY, int height, int minZ, int depth) {
+    int debug8 = minY - minX + 1;
+    int debug9 = height - limit + 1;
+    int debug10 = minZ - width + 1;
+    return () -> new AbstractIterator<BlockPos>() {
+      final BlockPos.MutableBlockPos nextPos = new BlockPos.MutableBlockPos();
+
+      int counter = limit;
+
+      protected BlockPos computeNext() {
+        if (this.counter <= 0)
+          return (BlockPos)endOfData();
+        BlockPos debug1 = this.nextPos.set(minX + random
+                .nextInt(width), minY + random
+                .nextInt(height), minZ + random
+                .nextInt(depth));
+        this.counter--;
+        return debug1;
+      }
+    };
   }
+
+  public static Iterable<BlockPos> withinManhattan(final BlockPos origin, final int maxDepth, final int reachX, final int reachY) {
+    final int reachZ = maxDepth + reachX + reachY;
+    final int originZ = origin.getZ();
+    final int originX = origin.getX();
+    final int originY = origin.getY();
+    return () -> new AbstractIterator<BlockPos>() {
+      private final BlockPos.MutableBlockPos cursor = new BlockPos.MutableBlockPos();
+
+      private int currentDepth;
+
+      private int maxX;
+
+      private int maxY;
+
+      private int x;
+
+      private int y;
+
+      private boolean zMirror;
+
+      protected BlockPos computeNext() {
+        if (this.zMirror) {
+          this.zMirror = false;
+          this.cursor.setZ(originZ - this.cursor.getZ() - originZ);
+          return this.cursor;
+        }
+        BlockPos debug1 = null;
+        while (debug1 == null) {
+          if (this.y > this.maxY) {
+            this.x++;
+            if (this.x > this.maxX) {
+              this.currentDepth++;
+              if (this.currentDepth > maxDepth)
+                return (BlockPos)endOfData();
+              this.maxX = Math.min(reachX, this.currentDepth);
+              this.x = -this.maxX;
+            }
+            this.maxY = Math.min(reachY, this.currentDepth - Math.abs(this.x));
+            this.y = -this.maxY;
+          }
+          int debug2 = this.x;
+          int debug3 = this.y;
+          int debug4 = this.currentDepth - Math.abs(debug2) - Math.abs(debug3);
+          if (debug4 <= reachZ) {
+            this.zMirror = (debug4 != 0);
+            debug1 = this.cursor.set(originX + debug2, originY + debug3, originZ + debug4);
+          }
+          this.y++;
+        }
+        return debug1;
+      }
+    };
+  }
+  // MagmaCube end - decompile fix
   
   public static Optional<BlockPos> findClosestMatch(BlockPos debug0, int debug1, int debug2, Predicate<BlockPos> debug3) {
     return withinManhattanStream(debug0, debug1, debug2, debug1).filter(debug3).findFirst();
@@ -275,17 +451,71 @@ public class BlockPos extends Vec3i {
   public static Stream<BlockPos> betweenClosedStream(int debug0, int debug1, int debug2, int debug3, int debug4, int debug5) {
     return StreamSupport.stream(betweenClosed(debug0, debug1, debug2, debug3, debug4, debug5).spliterator(), false);
   }
-  
-  public static Iterable<BlockPos> betweenClosed(int debug0, int debug1, int debug2, int debug3, int debug4, int debug5) {
-    int debug6 = debug3 - debug0 + 1;
-    int debug7 = debug4 - debug1 + 1;
-    int debug8 = debug5 - debug2 + 1;
+
+  // MagmaCube start - decompile fix
+  public static Iterable<BlockPos> betweenClosed(final int end, final int width, final int height, final int minX, final int minY, final int minZ) {
+    int debug6 = minX - end + 1;
+    int debug7 = minY - width + 1;
+    int debug8 = minZ - height + 1;
     int debug9 = debug6 * debug7 * debug8;
-    return () -> new Object(debug0, debug1, debug2, debug3, debug4, debug5);
-  }
-  
-  public static Iterable<MutableBlockPos> spiralAround(BlockPos debug0, int debug1, Direction debug2, Direction debug3) {
-    Validate.validState((debug2.getAxis() != debug3.getAxis()), "The two directions cannot be on the same axis", new Object[0]);
-    return () -> new Object(debug0, debug1, debug2, debug3);
+    return () -> new AbstractIterator<BlockPos>() {
+      private final BlockPos.MutableBlockPos cursor = new BlockPos.MutableBlockPos();
+
+      private int index;
+
+      protected BlockPos computeNext() {
+        if (this.index == end)
+          return (BlockPos)endOfData();
+        int debug1 = this.index % width;
+        int debug2 = this.index / width;
+        int debug3 = debug2 % height;
+        int debug4 = debug2 / height;
+        this.index++;
+        return this.cursor.set(minX + debug1, minY + debug3, minZ + debug4);
+      }
+    };
   }
+
+  public static Iterable<MutableBlockPos> spiralAround(final BlockPos center, final int radius, final Direction firstDirection, final Direction secondDirection) {
+    Validate.validState((firstDirection.getAxis() != secondDirection.getAxis()), "The two directions cannot be on the same axis", new Object[0]);
+    return () -> new AbstractIterator<MutableBlockPos>() {
+      private final Direction[] directions = new Direction[] { firstDirection, secondDirection, firstDirection
+
+              .getOpposite(), secondDirection
+              .getOpposite() };
+
+      private final BlockPos.MutableBlockPos cursor = center.mutable().move(secondDirection);
+
+      private final int legs = 4 * radius;
+
+      private int leg = -1;
+
+      private int legSize;
+
+      private int legIndex;
+
+      private int lastX = this.cursor.getX();
+
+      private int lastY = this.cursor.getY();
+
+      private int lastZ = this.cursor.getZ();
+
+      protected BlockPos.MutableBlockPos computeNext() {
+        this.cursor.set(this.lastX, this.lastY, this.lastZ).move(this.directions[(this.leg + 4) % 4]);
+        this.lastX = this.cursor.getX();
+        this.lastY = this.cursor.getY();
+        this.lastZ = this.cursor.getZ();
+        if (this.legIndex >= this.legSize) {
+          if (this.leg >= this.legs)
+            return (BlockPos.MutableBlockPos)endOfData();
+          this.leg++;
+          this.legIndex = 0;
+          this.legSize = this.leg / 2 + 1;
+        }
+        this.legIndex++;
+        return this.cursor;
+      }
+    };
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/core/Direction.java b/src/main/java/net/minecraft/core/Direction.java
index 130a866c39a6544881f75b5e61f08baf5bba6fb7..ee9d364a00fd4e87e64f10f986cfd057aec7cf3b 100644
--- a/src/main/java/net/minecraft/core/Direction.java
+++ b/src/main/java/net/minecraft/core/Direction.java
@@ -1,17 +1,22 @@
 package net.minecraft.core;
 
+import com.google.common.collect.Iterators;
 import com.mojang.math.Matrix4f;
 import com.mojang.math.Quaternion;
 import com.mojang.math.Vector3f;
 import com.mojang.math.Vector4f;
+import com.mojang.serialization.Codec;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import java.util.Arrays;
 import java.util.Comparator;
+import java.util.Iterator;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Random;
+import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.util.Mth;
@@ -57,7 +62,7 @@ public enum Direction implements StringRepresentable {
     BY_2D_DATA = (Direction[])Arrays.<Direction>stream(VALUES).filter(debug0 -> debug0.getAxis().isHorizontal()).sorted(Comparator.comparingInt(debug0 -> debug0.data2d)).toArray(debug0 -> new Direction[debug0]);
     BY_NORMAL = (Long2ObjectMap<Direction>)Arrays.<Direction>stream(VALUES).collect(Collectors.toMap(debug0 -> Long.valueOf((new BlockPos(debug0.getNormal())).asLong()), debug0 -> debug0, (debug0, debug1) -> {
             throw new IllegalArgumentException("Duplicate keys");
-          }it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap::new));
+          }, it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap::new)); // MagmaCube - decompile fix
   }
   
   Direction(int debug3, int debug4, int debug5, String debug6, AxisDirection debug7, Axis debug8, Vec3i debug9) {
@@ -115,7 +120,7 @@ public enum Direction implements StringRepresentable {
   
   public Quaternion getRotation() {
     Quaternion debug1 = Vector3f.XP.rotationDegrees(90.0F);
-    switch (null.$SwitchMap$net$minecraft$core$Direction[ordinal()]) {
+    switch (ordinal()) { // MagmaCube - decompile fix
       case 1:
         return Vector3f.XP.rotationDegrees(180.0F);
       case 2:
@@ -150,7 +155,7 @@ public enum Direction implements StringRepresentable {
   }
   
   public Direction getClockWise() {
-    switch (null.$SwitchMap$net$minecraft$core$Direction[ordinal()]) {
+    switch (ordinal()) { // MagmaCube - decompile fix
       case 3:
         return EAST;
       case 6:
@@ -164,7 +169,7 @@ public enum Direction implements StringRepresentable {
   }
   
   public Direction getCounterClockWise() {
-    switch (null.$SwitchMap$net$minecraft$core$Direction[ordinal()]) {
+    switch (ordinal()) { // MagmaCube - decompile fix
       case 3:
         return WEST;
       case 6:
@@ -226,7 +231,7 @@ public enum Direction implements StringRepresentable {
   }
   
   public static Direction fromAxisAndDirection(Axis debug0, AxisDirection debug1) {
-    switch (null.$SwitchMap$net$minecraft$core$Direction$Axis[debug0.ordinal()]) {
+    switch (debug0.ordinal()) { // MagmaCube - decompile fix
       case 1:
         return (debug1 == AxisDirection.POSITIVE) ? EAST : WEST;
       case 2:
@@ -275,15 +280,167 @@ public enum Direction implements StringRepresentable {
     } 
     throw new IllegalArgumentException("No such direction: " + debug0 + " " + debug1);
   }
+
+  // MagmaCube start - decompile fix
+  public enum Axis implements StringRepresentable, Predicate<Direction> {
+    X("x") {
+      public int choose(int debug1, int debug2, int debug3) {
+        return debug1;
+      }
+
+      public double choose(double debug1, double debug3, double debug5) {
+        return debug1;
+      }
+    },
+    Y("y") {
+      public int choose(int debug1, int debug2, int debug3) {
+        return debug2;
+      }
+
+      public double choose(double debug1, double debug3, double debug5) {
+        return debug3;
+      }
+    },
+    Z("z") {
+      public int choose(int debug1, int debug2, int debug3) {
+        return debug3;
+      }
+
+      public double choose(double debug1, double debug3, double debug5) {
+        return debug5;
+      }
+    };
+
+    private static final Axis[] VALUES = values();
+
+    public static final Codec<Axis> CODEC = StringRepresentable.fromEnum(Axis::values, Axis::byName);
+
+    private static final Map<String, Axis> BY_NAME;
+
+    private final String name;
+
+    static {
+      BY_NAME = (Map<String, Axis>)Arrays.<Axis>stream(VALUES).collect(Collectors.toMap(Axis::getName, debug0 -> debug0));
+    }
+
+    Axis(String debug3) {
+      this.name = debug3;
+    }
+
+    @Nullable
+    public static Axis byName(String debug0) {
+      return BY_NAME.get(debug0.toLowerCase(Locale.ROOT));
+    }
+
+    public String getName() {
+      return this.name;
+    }
+
+    public boolean isVertical() {
+      return (this == Y);
+    }
+
+    public boolean isHorizontal() {
+      return (this == X || this == Z);
+    }
+
+    public String toString() {
+      return this.name;
+    }
+
+    public static Axis getRandom(Random debug0) {
+      return (Axis)Util.getRandom((Object[])VALUES, debug0);
+    }
+
+    public boolean test(@Nullable Direction debug1) {
+      return (debug1 != null && debug1.getAxis() == this);
+    }
+
+    public Direction.Plane getPlane() {
+      switch (this) {
+        case X:
+        case Z:
+          return Direction.Plane.HORIZONTAL;
+        case Y:
+          return Direction.Plane.VERTICAL;
+      }
+      throw new Error("Someone's been tampering with the universe!");
+    }
+
+    public String getSerializedName() {
+      return this.name;
+    }
+
+    public abstract int choose(int param1Int1, int param1Int2, int param1Int3);
+
+    public abstract double choose(double param1Double1, double param1Double2, double param1Double3);
+  }
+
+  public enum AxisDirection {
+    POSITIVE(1, "Towards positive"),
+    NEGATIVE(-1, "Towards negative");
+
+    private final int step;
+
+    private final String name;
+
+    AxisDirection(int debug3, String debug4) {
+      this.step = debug3;
+      this.name = debug4;
+    }
+
+    public int getStep() {
+      return this.step;
+    }
+
+    public String toString() {
+      return this.name;
+    }
+
+    public AxisDirection opposite() {
+      return (this == POSITIVE) ? NEGATIVE : POSITIVE;
+    }
+  }
   
   public Vec3i getNormal() {
     return this.normal;
   }
-  
+
   public boolean isFacingAngle(float debug1) {
     float debug2 = debug1 * 0.017453292F;
     float debug3 = -Mth.sin(debug2);
     float debug4 = Mth.cos(debug2);
     return (this.normal.getX() * debug3 + this.normal.getZ() * debug4 > 0.0F);
   }
+
+  public enum Plane implements Iterable<Direction>, Predicate<Direction> {
+    HORIZONTAL(new Direction[] { Direction.NORTH, Direction.EAST, Direction.SOUTH, Direction.WEST }, new Direction.Axis[] { Direction.Axis.X, Direction.Axis.Z }),
+    VERTICAL(new Direction[] { Direction.UP, Direction.DOWN }, new Direction.Axis[] { Direction.Axis.Y });
+
+    private final Direction[] faces;
+
+    private final Direction.Axis[] axis;
+
+    Plane(Direction[] debug3, Direction.Axis[] debug4) {
+      this.faces = debug3;
+      this.axis = debug4;
+    }
+
+    public Direction getRandomDirection(Random debug1) {
+      return (Direction)Util.getRandom((Object[])this.faces, debug1);
+    }
+
+    public boolean test(@Nullable Direction debug1) {
+      return (debug1 != null && debug1.getAxis().getPlane() == this);
+    }
+
+    public Iterator<Direction> iterator() {
+      return (Iterator<Direction>) Iterators.forArray(this.faces);
+    }
+
+    public Stream<Direction> stream() {
+      return Arrays.stream(this.faces);
+    }
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/core/RegistryAccess.java b/src/main/java/net/minecraft/core/RegistryAccess.java
index 8aa047dde179a845a201e337503f4dae8412576c..870f822958f1fd79e266ff63b10dd6bc3442f74c 100644
--- a/src/main/java/net/minecraft/core/RegistryAccess.java
+++ b/src/main/java/net/minecraft/core/RegistryAccess.java
@@ -1,17 +1,19 @@
 package net.minecraft.core;
 
 import com.google.common.collect.ImmutableMap;
-import com.mojang.serialization.Codec;
-import com.mojang.serialization.DataResult;
-import com.mojang.serialization.DynamicOps;
-import com.mojang.serialization.Encoder;
-import com.mojang.serialization.JsonOps;
+import com.mojang.serialization.*;
+
 import java.util.Map;
 import java.util.Optional;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import com.mojang.serialization.codecs.UnboundedMapCodec;
 import net.minecraft.Util;
 import net.minecraft.data.BuiltinRegistries;
 import net.minecraft.resources.RegistryReadOps;
 import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.dimension.DimensionType;
 import net.minecraft.world.level.levelgen.NoiseGeneratorSettings;
@@ -24,6 +26,8 @@ import net.minecraft.world.level.levelgen.surfacebuilders.ConfiguredSurfaceBuild
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+import javax.annotation.Nullable;
+
 public abstract class RegistryAccess {
   private static final Logger LOGGER = LogManager.getLogger();
   
@@ -32,12 +36,46 @@ public abstract class RegistryAccess {
   private static final RegistryHolder BUILTIN;
   
   public <E> WritableRegistry<E> registryOrThrow(ResourceKey<? extends Registry<E>> debug1) {
-    return (WritableRegistry<E>)registry(debug1).orElseThrow(() -> new IllegalStateException("Missing registry: " + debug0));
+    return (WritableRegistry<E>)registry(debug1).orElseThrow(() -> new IllegalStateException("Missing registry: " + debug1)); // MagmaCube - decompile fix
   }
   
   public Registry<DimensionType> dimensionTypes() {
     return (Registry)registryOrThrow(Registry.DIMENSION_TYPE_REGISTRY);
   }
+
+  // MagmaCube start - decompile fix
+  static final class RegistryData<E> {
+    private final ResourceKey<? extends Registry<E>> key;
+
+    private final Codec<E> codec;
+
+    @Nullable
+    private final Codec<E> networkCodec;
+
+    public RegistryData(ResourceKey<? extends Registry<E>> debug1, Codec<E> debug2, @Nullable Codec<E> debug3) {
+      this.key = debug1;
+      this.codec = debug2;
+      this.networkCodec = debug3;
+    }
+
+    public ResourceKey<? extends Registry<E>> key() {
+      return this.key;
+    }
+
+    public Codec<E> codec() {
+      return this.codec;
+    }
+
+    @Nullable
+    public Codec<E> networkCodec() {
+      return this.networkCodec;
+    }
+
+    public boolean sendToClient() {
+      return (this.networkCodec != null);
+    }
+  }
+  // MagmaCube end - decompile fix
   
   static {
     REGISTRIES = (Map<ResourceKey<? extends Registry<?>>, RegistryData<?>>)Util.make(() -> {
@@ -56,7 +94,7 @@ public abstract class RegistryAccess {
     BUILTIN = (RegistryHolder)Util.make(() -> {
           RegistryHolder debug0 = new RegistryHolder();
           DimensionType.registerBuiltin(debug0);
-          REGISTRIES.keySet().stream().filter(()).forEach(());
+          //REGISTRIES.keySet().stream().filter(()).forEach(()); // MagmaCube - todo: unknown thing
           return debug0;
         });
   }
@@ -68,6 +106,45 @@ public abstract class RegistryAccess {
   private static <E> void put(ImmutableMap.Builder<ResourceKey<? extends Registry<?>>, RegistryData<?>> debug0, ResourceKey<? extends Registry<E>> debug1, Codec<E> debug2, Codec<E> debug3) {
     debug0.put(debug1, new RegistryData(debug1, debug2, debug3));
   }
+
+  // MagmaCube start - decompile fix
+  public static final class RegistryHolder extends RegistryAccess {
+    public static final Codec<RegistryHolder> NETWORK_CODEC = makeNetworkCodec();
+
+    private final Map<? extends ResourceKey<? extends Registry<?>>, ? extends MappedRegistry<?>> registries;
+
+    private static <E> Codec<RegistryHolder> makeNetworkCodec() {
+      Codec<ResourceKey<? extends Registry<E>>> debug0 = ResourceLocation.CODEC.xmap(ResourceKey::createRegistryKey, ResourceKey::location);
+      Codec<MappedRegistry<E>> debug1 = debug0.partialDispatch("type", debug02 -> DataResult.success(debug02), debug02 -> getNetworkCodec(debug02));
+      UnboundedMapCodec<? extends ResourceKey<? extends Registry<?>>, ? extends MappedRegistry<?>> debug2 = Codec.unboundedMap(debug0, debug1);
+      return captureMap(debug2);
+    }
+
+    private static <K extends ResourceKey<? extends Registry<?>>, V extends MappedRegistry<?>> Codec<RegistryHolder> captureMap(UnboundedMapCodec<K, V> debug0) {
+      return debug0.xmap(RegistryHolder::new, debug02 -> (Map)debug02.registries.entrySet().stream().collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, Map.Entry::getValue)));
+    } //                                                                                            ^ #filter goes around here
+
+    private static <E> DataResult<? extends Codec<E>> getNetworkCodec(ResourceKey<? extends Registry<E>> debug0) {
+      return (DataResult<? extends Codec<E>>) Optional.ofNullable(RegistryAccess.REGISTRIES.get(debug0)).map(debug02 -> debug02.networkCodec()).map(DataResult::success).orElseGet(() -> DataResult.error("Unknown or not serializable registry: " + debug0));
+    }
+
+    public RegistryHolder() {
+      this((Map<? extends ResourceKey<? extends Registry<?>>, ? extends MappedRegistry<?>>)RegistryAccess.REGISTRIES.keySet().stream().collect(Collectors.toMap(Function.identity(), RegistryHolder::createRegistry)));
+    }
+
+    private RegistryHolder(Map<? extends ResourceKey<? extends Registry<?>>, ? extends MappedRegistry<?>> debug1) {
+      this.registries = debug1;
+    }
+
+    private static <E> MappedRegistry<?> createRegistry(ResourceKey<? extends Registry<?>> debug0) {
+      return new MappedRegistry(debug0, Lifecycle.stable());
+    }
+
+    public <E> Optional<WritableRegistry<E>> registry(ResourceKey<? extends Registry<E>> debug1) {
+      return (Optional<WritableRegistry<E>>) Optional.ofNullable(this.registries.get(debug1)).map(debug0 -> debug0); // MagmaCube - todo: it may not work
+    }
+  }
+  // MagmaCube end - decompile fix
   
   public static RegistryHolder builtin() {
     RegistryHolder debug0 = new RegistryHolder();
diff --git a/src/main/java/net/minecraft/network/protocol/game/ServerboundPlayerActionPacket.java b/src/main/java/net/minecraft/network/protocol/game/ServerboundPlayerActionPacket.java
index 5c8eccaa5935a347c84adb97ffec09f6b59cbaae..deaa79afcceb293bc23bb1f6dca8e09a99a0c64d 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ServerboundPlayerActionPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ServerboundPlayerActionPacket.java
@@ -49,4 +49,10 @@ public class ServerboundPlayerActionPacket implements Packet<ServerGamePacketLis
   public Action getAction() {
     return this.action;
   }
+
+  // MagmaCube start - decompile fix
+  public enum Action {
+    START_DESTROY_BLOCK, ABORT_DESTROY_BLOCK, STOP_DESTROY_BLOCK, DROP_ALL_ITEMS, DROP_ITEM, RELEASE_USE_ITEM, SWAP_ITEM_WITH_OFFHAND;
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/server/packs/resources/SimpleReloadableResourceManager.java b/src/main/java/net/minecraft/server/packs/resources/SimpleReloadableResourceManager.java
index 3b2c99c800a6c4bf6a1a462ea1333bfe896e9f33..b331d9969be8fcc38f64a3131b868c4099ec4bae 100644
--- a/src/main/java/net/minecraft/server/packs/resources/SimpleReloadableResourceManager.java
+++ b/src/main/java/net/minecraft/server/packs/resources/SimpleReloadableResourceManager.java
@@ -106,7 +106,7 @@ public class SimpleReloadableResourceManager implements ReloadableResourceManage
   }
   
   protected ReloadInstance createReload(Executor debug1, Executor debug2, List<PreparableReloadListener> debug3, CompletableFuture<Unit> debug4) {
-    SimpleReloadInstance simpleReloadInstance;
+    SimpleReloadInstance simpleReloadInstance = null; // MagmaCube - decompile fix
     if (LOGGER.isDebugEnabled()) {
       ProfiledReloadInstance profiledReloadInstance = new ProfiledReloadInstance((ResourceManager)this, Lists.newArrayList(debug3), debug1, debug2, debug4);
     } else {
@@ -118,7 +118,7 @@ public class SimpleReloadableResourceManager implements ReloadableResourceManage
   
   public ReloadInstance createFullReload(Executor debug1, Executor debug2, CompletableFuture<Unit> debug3, List<PackResources> debug4) {
     clear();
-    LOGGER.info("Reloading ResourceManager: {}", new Supplier[] { () -> (String)debug0.stream().map(PackResources::getName).collect(Collectors.joining(", ")) });
+    LOGGER.info("Reloading ResourceManager: {}", new Supplier[] { () -> (String)debug4.stream().map(PackResources::getName).collect(Collectors.joining(", ")) }); // MagmaCube - decompile fix
     for (PackResources debug6 : debug4) {
       try {
         add(debug6);
@@ -133,4 +133,51 @@ public class SimpleReloadableResourceManager implements ReloadableResourceManage
   public Stream<PackResources> listPacks() {
     return this.packs.stream();
   }
+
+  // MagmaCube start - decompile fix
+  public static class ResourcePackLoadingFailure extends RuntimeException {
+    private final PackResources pack;
+
+    public ResourcePackLoadingFailure(PackResources debug1, Throwable debug2) {
+      super(debug1.getName(), debug2);
+      this.pack = debug1;
+    }
+
+    public PackResources getPack() {
+      return this.pack;
+    }
+  }
+
+  static class FailingReloadInstance implements ReloadInstance {
+    private final SimpleReloadableResourceManager.ResourcePackLoadingFailure exception;
+
+    private final CompletableFuture<Unit> failedFuture;
+
+    public FailingReloadInstance(SimpleReloadableResourceManager.ResourcePackLoadingFailure debug1) {
+      this.exception = debug1;
+      this.failedFuture = new CompletableFuture<>();
+      this.failedFuture.completeExceptionally(debug1);
+    }
+
+    public CompletableFuture<Unit> done() {
+      return this.failedFuture;
+    }
+
+    public float getActualProgress() {
+      return 0.0F;
+    }
+
+    public boolean isApplying() {
+      return false;
+    }
+
+    public boolean isDone() {
+      return true;
+    }
+
+    public void checkExceptions() {
+      throw this.exception;
+    }
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/tags/Tag.java b/src/main/java/net/minecraft/tags/Tag.java
index 68c867333805de20baa7d2c0890b0c324c2fc155..cf7be895cec27e55668e69889598d54b8882507a 100644
--- a/src/main/java/net/minecraft/tags/Tag.java
+++ b/src/main/java/net/minecraft/tags/Tag.java
@@ -1,29 +1,252 @@
 package net.minecraft.tags;
 
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.DataResult;
 import java.util.List;
 import java.util.Optional;
 import java.util.Random;
 import java.util.Set;
+import java.util.function.Consumer;
+import java.util.function.Function;
 import java.util.function.Supplier;
+import java.util.stream.Stream;
+
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.util.GsonHelper;
 
 public interface Tag<T> {
   static <T> Codec<Tag<T>> codec(Supplier<TagCollection<T>> debug0) {
-    return ResourceLocation.CODEC.flatXmap(debug1 -> (DataResult)Optional.<Tag>ofNullable(((TagCollection)debug0.get()).getTag(debug1)).map(DataResult::success).orElseGet(()), debug1 -> (DataResult)Optional.<ResourceLocation>ofNullable(((TagCollection)debug0.get()).getId(debug1)).map(DataResult::success).orElseGet(()));
+    return ResourceLocation.CODEC.flatXmap(debug1 -> (DataResult)Optional.<Tag>ofNullable(((TagCollection)debug0.get()).getTag(debug1)).map(DataResult::success).orElseGet(null), debug1 -> (DataResult)Optional.<ResourceLocation>ofNullable(((TagCollection)debug0.get()).getId(debug1)).map(DataResult::success).orElseGet(null)); // MagmaCube - decompile fix
   }
   
   default T getRandomElement(Random debug1) {
     List<T> debug2 = getValues();
     return debug2.get(debug1.nextInt(debug2.size()));
   }
-  
+
+  // MagmaCube start - decompile fix
+  public static class BuilderEntry {
+    private final Tag.Entry entry;
+
+    private final String source;
+
+    private BuilderEntry(Tag.Entry debug1, String debug2) {
+      this.entry = debug1;
+      this.source = debug2;
+    }
+
+    public Tag.Entry getEntry() {
+      return this.entry;
+    }
+
+    public String toString() {
+      return this.entry.toString() + " (from " + this.source + ")";
+    }
+  }
+
+  public static class Builder {
+    private final List<Tag.BuilderEntry> entries = Lists.newArrayList();
+
+    public static Builder tag() {
+      return new Builder();
+    }
+
+    public Builder add(Tag.BuilderEntry debug1) {
+      this.entries.add(debug1);
+      return this;
+    }
+
+    public Builder add(Tag.Entry debug1, String debug2) {
+      return add(new Tag.BuilderEntry(debug1, debug2));
+    }
+
+    public Builder addElement(ResourceLocation debug1, String debug2) {
+      return add(new Tag.ElementEntry(debug1), debug2);
+    }
+
+    public Builder addTag(ResourceLocation debug1, String debug2) {
+      return add(new Tag.TagEntry(debug1), debug2);
+    }
+
+    public <T> Optional<Tag<T>> build(Function<ResourceLocation, Tag<T>> debug1, Function<ResourceLocation, T> debug2) {
+      ImmutableSet.Builder<T> debug3 = ImmutableSet.builder();
+      for (Tag.BuilderEntry debug5 : this.entries) {
+        if (!debug5.getEntry().build(debug1, debug2, debug3::add))
+          return Optional.empty();
+      }
+      return Optional.of(Tag.fromSet((Set<T>)debug3.build()));
+    }
+
+    public Stream<Tag.BuilderEntry> getEntries() {
+      return this.entries.stream();
+    }
+
+    public <T> Stream<BuilderEntry> getUnresolvedEntries(Function<ResourceLocation, Tag<T>> debug1, Function<ResourceLocation, T> debug2) {
+      return getEntries().filter(debug22 -> !debug22.getEntry().build(debug1, debug2, t -> {}));
+    }
+
+    public Builder addFromJson(JsonObject debug1, String debug2) {
+      JsonArray debug3 = GsonHelper.getAsJsonArray(debug1, "values");
+      List<Tag.Entry> debug4 = Lists.newArrayList();
+      for (JsonElement debug6 : debug3)
+        debug4.add(parseEntry(debug6));
+      if (GsonHelper.getAsBoolean(debug1, "replace", false))
+        this.entries.clear();
+      debug4.forEach(debug22 -> this.entries.add(new Tag.BuilderEntry(debug22, debug2)));
+      return this;
+    }
+
+    private static Tag.Entry parseEntry(JsonElement debug0) {
+      String debug1;
+      boolean debug2;
+      if (debug0.isJsonObject()) {
+        JsonObject jsonObject = debug0.getAsJsonObject();
+        debug1 = GsonHelper.getAsString(jsonObject, "id");
+        debug2 = GsonHelper.getAsBoolean(jsonObject, "required", true);
+      } else {
+        debug1 = GsonHelper.convertToString(debug0, "id");
+        debug2 = true;
+      }
+      if (debug1.startsWith("#")) {
+        ResourceLocation resourceLocation = new ResourceLocation(debug1.substring(1));
+        return debug2 ? new Tag.TagEntry(resourceLocation) : new Tag.OptionalTagEntry(resourceLocation);
+      }
+      ResourceLocation debug3 = new ResourceLocation(debug1);
+      return debug2 ? new Tag.ElementEntry(debug3) : new Tag.OptionalElementEntry(debug3);
+    }
+
+    public JsonObject serializeToJson() {
+      JsonObject debug1 = new JsonObject();
+      JsonArray debug2 = new JsonArray();
+      for (Tag.BuilderEntry debug4 : this.entries)
+        debug4.getEntry().serializeTo(debug2);
+      debug1.addProperty("replace", Boolean.valueOf(false));
+      debug1.add("values", (JsonElement)debug2);
+      return debug1;
+    }
+  }
+
+  public static interface Entry {
+    <T> boolean build(Function<ResourceLocation, Tag<T>> param1Function, Function<ResourceLocation, T> param1Function1, Consumer<T> param1Consumer);
+
+    void serializeTo(JsonArray param1JsonArray);
+  }
+
+  public static class ElementEntry implements Entry {
+    private final ResourceLocation id;
+
+    public ElementEntry(ResourceLocation debug1) {
+      this.id = debug1;
+    }
+
+    public <T> boolean build(Function<ResourceLocation, Tag<T>> debug1, Function<ResourceLocation, T> debug2, Consumer<T> debug3) {
+      T debug4 = debug2.apply(this.id);
+      if (debug4 == null)
+        return false;
+      debug3.accept(debug4);
+      return true;
+    }
+
+    public void serializeTo(JsonArray debug1) {
+      debug1.add(this.id.toString());
+    }
+
+    public String toString() {
+      return this.id.toString();
+    }
+  }
+
+  public static class OptionalElementEntry implements Entry {
+    private final ResourceLocation id;
+
+    public OptionalElementEntry(ResourceLocation debug1) {
+      this.id = debug1;
+    }
+
+    public <T> boolean build(Function<ResourceLocation, Tag<T>> debug1, Function<ResourceLocation, T> debug2, Consumer<T> debug3) {
+      T debug4 = debug2.apply(this.id);
+      if (debug4 != null)
+        debug3.accept(debug4);
+      return true;
+    }
+
+    public void serializeTo(JsonArray debug1) {
+      JsonObject debug2 = new JsonObject();
+      debug2.addProperty("id", this.id.toString());
+      debug2.addProperty("required", Boolean.valueOf(false));
+      debug1.add((JsonElement)debug2);
+    }
+
+    public String toString() {
+      return this.id.toString() + "?";
+    }
+  }
+
+  public static class TagEntry implements Entry {
+    private final ResourceLocation id;
+
+    public TagEntry(ResourceLocation debug1) {
+      this.id = debug1;
+    }
+
+    public <T> boolean build(Function<ResourceLocation, Tag<T>> debug1, Function<ResourceLocation, T> debug2, Consumer<T> debug3) {
+      Tag<T> debug4 = debug1.apply(this.id);
+      if (debug4 == null)
+        return false;
+      debug4.getValues().forEach(debug3);
+      return true;
+    }
+
+    public void serializeTo(JsonArray debug1) {
+      debug1.add("#" + this.id);
+    }
+
+    public String toString() {
+      return "#" + this.id;
+    }
+  }
+
+  public static class OptionalTagEntry implements Entry {
+    private final ResourceLocation id;
+
+    public OptionalTagEntry(ResourceLocation debug1) {
+      this.id = debug1;
+    }
+
+    public <T> boolean build(Function<ResourceLocation, Tag<T>> debug1, Function<ResourceLocation, T> debug2, Consumer<T> debug3) {
+      Tag<T> debug4 = debug1.apply(this.id);
+      if (debug4 != null)
+        debug4.getValues().forEach(debug3);
+      return true;
+    }
+
+    public void serializeTo(JsonArray debug1) {
+      JsonObject debug2 = new JsonObject();
+      debug2.addProperty("id", "#" + this.id);
+      debug2.addProperty("required", false);
+      debug1.add((JsonElement)debug2);
+    }
+
+    public String toString() {
+      return "#" + this.id + "?";
+    }
+  }
+
   static <T> Tag<T> fromSet(Set<T> debug0) {
-    return (Tag<T>)SetTag.create(debug0);
+    return SetTag.create(debug0);
   }
-  
+
   boolean contains(T paramT);
-  
+
   List<T> getValues();
+
+  public static interface Named<T> extends Tag<T> {
+    ResourceLocation getName();
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/world/item/FireworkRocketItem.java b/src/main/java/net/minecraft/world/item/FireworkRocketItem.java
index 650d66835023f1368043e8d56f09c779953446bb..7f5516278df462c641be9c64ae9a07e4b8c810ee 100644
--- a/src/main/java/net/minecraft/world/item/FireworkRocketItem.java
+++ b/src/main/java/net/minecraft/world/item/FireworkRocketItem.java
@@ -1,6 +1,9 @@
 package net.minecraft.world.item;
 
 import com.google.common.collect.Lists;
+
+import java.util.Arrays;
+import java.util.Comparator;
 import java.util.List;
 import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
@@ -25,6 +28,45 @@ public class FireworkRocketItem extends Item {
   public FireworkRocketItem(Item.Properties debug1) {
     super(debug1);
   }
+
+  // MagmaCube start - decompile fix
+  public enum Shape {
+    SMALL_BALL(0, "small_ball"),
+    LARGE_BALL(1, "large_ball"),
+    STAR(2, "star"),
+    CREEPER(3, "creeper"),
+    BURST(4, "burst");
+
+    private static final Shape[] BY_ID;
+
+    private final int id;
+
+    private final String name;
+
+    static {
+      BY_ID = (Shape[]) Arrays.<Shape>stream(values()).sorted(Comparator.comparingInt(debug0 -> debug0.id)).toArray(debug0 -> new Shape[debug0]);
+    }
+
+    Shape(int debug3, String debug4) {
+      this.id = debug3;
+      this.name = debug4;
+    }
+
+    public int getId() {
+      return this.id;
+    }
+
+    public String getName() {
+      return this.name;
+    }
+
+    public static Shape byId(int debug0) {
+      if (debug0 < 0 || debug0 >= BY_ID.length)
+        return SMALL_BALL;
+      return BY_ID[debug0];
+    }
+  }
+  // MagmaCube end - decompile fix
   
   public InteractionResult useOn(UseOnContext debug1) {
     Level debug2 = debug1.getLevel();
diff --git a/src/main/java/net/minecraft/world/item/Item.java b/src/main/java/net/minecraft/world/item/Item.java
index c51943f84292a60216a0154bd65a5efedfeee443..4e8b61699ef1faf258c2a75988e98e3ece5ab6d7 100644
--- a/src/main/java/net/minecraft/world/item/Item.java
+++ b/src/main/java/net/minecraft/world/item/Item.java
@@ -80,14 +80,74 @@ public class Item implements ItemLike {
   }
   
   public Item(Properties debug1) {
-    this.category = Properties.access$000(debug1);
-    this.rarity = Properties.access$100(debug1);
-    this.craftingRemainingItem = Properties.access$200(debug1);
-    this.maxDamage = Properties.access$300(debug1);
-    this.maxStackSize = Properties.access$400(debug1);
-    this.foodProperties = Properties.access$500(debug1);
-    this.isFireResistant = Properties.access$600(debug1);
+    this.category = debug1.category;
+    this.rarity = debug1.rarity;
+    this.craftingRemainingItem = debug1.craftingRemainingItem;
+    this.maxDamage = debug1.maxDamage;
+    this.maxStackSize = debug1.maxStackSize;
+    this.foodProperties = debug1.foodProperties;
+    this.isFireResistant = debug1.isFireResistant;
   }
+
+  // MagmaCube start - decompile fix
+  public static class Properties {
+    private int maxStackSize = 64;
+
+    private int maxDamage;
+
+    private Item craftingRemainingItem;
+
+    private CreativeModeTab category;
+
+    private Rarity rarity = Rarity.COMMON;
+
+    private FoodProperties foodProperties;
+
+    private boolean isFireResistant;
+
+    public Properties food(FoodProperties debug1) {
+      this.foodProperties = debug1;
+      return this;
+    }
+
+    public Properties stacksTo(int debug1) {
+      if (this.maxDamage > 0)
+        throw new RuntimeException("Unable to have damage AND stack.");
+      this.maxStackSize = debug1;
+      return this;
+    }
+
+    public Properties defaultDurability(int debug1) {
+      return (this.maxDamage == 0) ? durability(debug1) : this;
+    }
+
+    public Properties durability(int debug1) {
+      this.maxDamage = debug1;
+      this.maxStackSize = 1;
+      return this;
+    }
+
+    public Properties craftRemainder(Item debug1) {
+      this.craftingRemainingItem = debug1;
+      return this;
+    }
+
+    public Properties tab(CreativeModeTab debug1) {
+      this.category = debug1;
+      return this;
+    }
+
+    public Properties rarity(Rarity debug1) {
+      this.rarity = debug1;
+      return this;
+    }
+
+    public Properties fireResistant() {
+      this.isFireResistant = true;
+      return this;
+    }
+  }
+  // MagmaCube end - decompile fix
   
   public void onUseTick(Level debug1, LivingEntity debug2, ItemStack debug3, int debug4) {}
   
@@ -225,7 +285,7 @@ public class Item implements ItemLike {
   public Rarity getRarity(ItemStack debug1) {
     if (!debug1.isEnchanted())
       return this.rarity; 
-    switch (null.$SwitchMap$net$minecraft$world$item$Rarity[this.rarity.ordinal()]) {
+    switch (this.rarity.ordinal()) { // MagmaCube - decompile fix
       case 1:
       case 2:
         return Rarity.RARE;
@@ -279,7 +339,7 @@ public class Item implements ItemLike {
   }
   
   public Multimap<Attribute, AttributeModifier> getDefaultAttributeModifiers(EquipmentSlot debug1) {
-    return (Multimap<Attribute, AttributeModifier>)ImmutableMultimap.of();
+    return (Multimap<Attribute, AttributeModifier>)(Object)ImmutableMultimap.of(); // MagmaCube - decompile fix
   }
   
   public boolean useOnRelease(ItemStack debug1) {
diff --git a/src/main/java/net/minecraft/world/item/TooltipFlag.java b/src/main/java/net/minecraft/world/item/TooltipFlag.java
index 6f7e4f0a970bcf9cac2b4766d509b2d7d23245d0..dc3781ce1f0d390fad02965bb2121bfda5613475 100644
--- a/src/main/java/net/minecraft/world/item/TooltipFlag.java
+++ b/src/main/java/net/minecraft/world/item/TooltipFlag.java
@@ -2,4 +2,21 @@ package net.minecraft.world.item;
 
 public interface TooltipFlag {
   boolean isAdvanced();
+
+  // MagmaCube start - decompile fix
+  public enum Default implements TooltipFlag {
+    NORMAL(false),
+    ADVANCED(true);
+
+    private final boolean advanced;
+
+    Default(boolean debug3) {
+      this.advanced = debug3;
+    }
+
+    public boolean isAdvanced() {
+      return this.advanced;
+    }
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/world/level/ClipContext.java b/src/main/java/net/minecraft/world/level/ClipContext.java
index 9c817c5cec5f84a53af0059fb06bbf2e0507efe9..44cc6ecbdb38cd225d0f4bbcbb8e9ebf2887cb72 100644
--- a/src/main/java/net/minecraft/world/level/ClipContext.java
+++ b/src/main/java/net/minecraft/world/level/ClipContext.java
@@ -2,6 +2,7 @@ package net.minecraft.world.level;
 
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.phys.Vec3;
@@ -9,6 +10,8 @@ import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
+import java.util.function.Predicate;
+
 public class ClipContext {
   private final Vec3 from;
   
@@ -43,4 +46,42 @@ public class ClipContext {
   public VoxelShape getFluidShape(FluidState debug1, BlockGetter debug2, BlockPos debug3) {
     return this.fluid.canPick(debug1) ? debug1.getShape(debug2, debug3) : Shapes.empty();
   }
+
+  // MagmaCube start - decompile fix
+  public enum Block implements ShapeGetter {
+    COLLIDER(BlockBehaviour.BlockStateBase::getCollisionShape),
+    OUTLINE(BlockBehaviour.BlockStateBase::getShape),
+    VISUAL(BlockBehaviour.BlockStateBase::getVisualShape);
+
+    private final ClipContext.ShapeGetter shapeGetter;
+
+    Block(ClipContext.ShapeGetter debug3) {
+      this.shapeGetter = debug3;
+    }
+
+    public VoxelShape get(BlockState debug1, BlockGetter debug2, BlockPos debug3, CollisionContext debug4) {
+      return this.shapeGetter.get(debug1, debug2, debug3, debug4);
+    }
+  }
+
+  public static interface ShapeGetter {
+    VoxelShape get(BlockState param1BlockState, BlockGetter param1BlockGetter, BlockPos param1BlockPos, CollisionContext param1CollisionContext);
+  }
+
+  public enum Fluid {
+    NONE((debug0 -> false)),
+    SOURCE_ONLY(FluidState::isSource),
+    ANY(FluidState::isSource);
+
+    private final Predicate<FluidState> canPick;
+
+    Fluid(Predicate<FluidState> debug3) {
+      this.canPick = debug3;
+    }
+
+    public boolean canPick(FluidState debug1) {
+      return this.canPick.test(debug1);
+    }
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/world/level/GameRules.java b/src/main/java/net/minecraft/world/level/GameRules.java
index 77ce64eb0c294f0d63e56be30618d95e4546f9f0..a40617d8a968de20fb45acb3029b269700d10ec0 100644
--- a/src/main/java/net/minecraft/world/level/GameRules.java
+++ b/src/main/java/net/minecraft/world/level/GameRules.java
@@ -2,10 +2,21 @@ package net.minecraft.world.level;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.arguments.BoolArgumentType;
+import com.mojang.brigadier.arguments.IntegerArgumentType;
+import com.mojang.brigadier.builder.RequiredArgumentBuilder;
+import com.mojang.brigadier.context.CommandContext;
 import com.mojang.serialization.DynamicLike;
 import java.util.Comparator;
 import java.util.Map;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
@@ -17,12 +28,34 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class GameRules {
+  // MagmaCube end - decompile fix
+  public enum Category {
+    PLAYER("gamerule.category.player"),
+    MOBS("gamerule.category.mobs"),
+    SPAWNING("gamerule.category.spawning"),
+    DROPS("gamerule.category.drops"),
+    UPDATES("gamerule.category.updates"),
+    CHAT("gamerule.category.chat"),
+    MISC("gamerule.category.misc");
+
+    private final String descriptionId;
+
+    Category(String debug3) {
+      this.descriptionId = debug3;
+    }
+
+    public String getDescriptionId() {
+      return this.descriptionId;
+    }
+  }
+  // MagmaCube start - decompile fix
+
   private static final Logger LOGGER = LogManager.getLogger();
   
   private static final Map<Key<?>, Type<?>> GAME_RULE_TYPES;
   
   static {
-    GAME_RULE_TYPES = Maps.newTreeMap(Comparator.comparing(debug0 -> Key.access$600(debug0)));
+    GAME_RULE_TYPES = Maps.newTreeMap(Comparator.comparing(debug0 -> debug0.id));
   }
   
   private static <T extends Value<T>> Key<T> register(String debug0, Category debug1, Type<T> debug2) {
@@ -33,86 +66,86 @@ public class GameRules {
     return debug3;
   }
   
-  public static final Key<BooleanValue> RULE_DOFIRETICK = register("doFireTick", Category.UPDATES, BooleanValue.access$000(true));
-  
-  public static final Key<BooleanValue> RULE_MOBGRIEFING = register("mobGriefing", Category.MOBS, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_DOFIRETICK = register("doFireTick", Category.UPDATES, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_KEEPINVENTORY = register("keepInventory", Category.PLAYER, BooleanValue.access$000(false));
+  public static final Key<BooleanValue> RULE_MOBGRIEFING = register("mobGriefing", Category.MOBS, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_DOMOBSPAWNING = register("doMobSpawning", Category.SPAWNING, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_KEEPINVENTORY = register("keepInventory", Category.PLAYER, BooleanValue.create(false));
   
-  public static final Key<BooleanValue> RULE_DOMOBLOOT = register("doMobLoot", Category.DROPS, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_DOMOBSPAWNING = register("doMobSpawning", Category.SPAWNING, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_DOBLOCKDROPS = register("doTileDrops", Category.DROPS, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_DOMOBLOOT = register("doMobLoot", Category.DROPS, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_DOENTITYDROPS = register("doEntityDrops", Category.DROPS, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_DOBLOCKDROPS = register("doTileDrops", Category.DROPS, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_COMMANDBLOCKOUTPUT = register("commandBlockOutput", Category.CHAT, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_DOENTITYDROPS = register("doEntityDrops", Category.DROPS, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_NATURAL_REGENERATION = register("naturalRegeneration", Category.PLAYER, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_COMMANDBLOCKOUTPUT = register("commandBlockOutput", Category.CHAT, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_DAYLIGHT = register("doDaylightCycle", Category.UPDATES, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_NATURAL_REGENERATION = register("naturalRegeneration", Category.PLAYER, BooleanValue.create(true));
+
+  public static final Key<BooleanValue> RULE_DAYLIGHT = register("doDaylightCycle", Category.UPDATES, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_LOGADMINCOMMANDS = register("logAdminCommands", Category.CHAT, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_LOGADMINCOMMANDS = register("logAdminCommands", Category.CHAT, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_SHOWDEATHMESSAGES = register("showDeathMessages", Category.CHAT, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_SHOWDEATHMESSAGES = register("showDeathMessages", Category.CHAT, BooleanValue.create(true));
   
-  public static final Key<IntegerValue> RULE_RANDOMTICKING = register("randomTickSpeed", Category.UPDATES, IntegerValue.access$100(3));
+  public static final Key<IntegerValue> RULE_RANDOMTICKING = register("randomTickSpeed", Category.UPDATES, IntegerValue.create(3));
   
-  public static final Key<BooleanValue> RULE_SENDCOMMANDFEEDBACK = register("sendCommandFeedback", Category.CHAT, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_SENDCOMMANDFEEDBACK = register("sendCommandFeedback", Category.CHAT, BooleanValue.create(true));
   
   public static final Key<BooleanValue> RULE_REDUCEDDEBUGINFO;
   
   static {
-    RULE_REDUCEDDEBUGINFO = register("reducedDebugInfo", Category.MISC, BooleanValue.access$200(false, (debug0, debug1) -> {
-            byte debug2 = debug1.get() ? 22 : 23;
+    RULE_REDUCEDDEBUGINFO = register("reducedDebugInfo", Category.MISC, BooleanValue.create(false, (debug0, debug1) -> {
+            byte debug2 = (byte) (debug1.get() ? 22 : 23);
             for (ServerPlayer debug4 : debug0.getPlayerList().getPlayers())
               debug4.connection.send((Packet)new ClientboundEntityEventPacket((Entity)debug4, debug2)); 
           }));
   }
   
-  public static final Key<BooleanValue> RULE_SPECTATORSGENERATECHUNKS = register("spectatorsGenerateChunks", Category.PLAYER, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_SPECTATORSGENERATECHUNKS = register("spectatorsGenerateChunks", Category.PLAYER, BooleanValue.create(true));
   
-  public static final Key<IntegerValue> RULE_SPAWN_RADIUS = register("spawnRadius", Category.PLAYER, IntegerValue.access$100(10));
+  public static final Key<IntegerValue> RULE_SPAWN_RADIUS = register("spawnRadius", Category.PLAYER, IntegerValue.create(10));
   
-  public static final Key<BooleanValue> RULE_DISABLE_ELYTRA_MOVEMENT_CHECK = register("disableElytraMovementCheck", Category.PLAYER, BooleanValue.access$000(false));
+  public static final Key<BooleanValue> RULE_DISABLE_ELYTRA_MOVEMENT_CHECK = register("disableElytraMovementCheck", Category.PLAYER, BooleanValue.create(false));
   
-  public static final Key<IntegerValue> RULE_MAX_ENTITY_CRAMMING = register("maxEntityCramming", Category.MOBS, IntegerValue.access$100(24));
+  public static final Key<IntegerValue> RULE_MAX_ENTITY_CRAMMING = register("maxEntityCramming", Category.MOBS, IntegerValue.create(24));
   
-  public static final Key<BooleanValue> RULE_WEATHER_CYCLE = register("doWeatherCycle", Category.UPDATES, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_WEATHER_CYCLE = register("doWeatherCycle", Category.UPDATES, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_LIMITED_CRAFTING = register("doLimitedCrafting", Category.PLAYER, BooleanValue.access$000(false));
+  public static final Key<BooleanValue> RULE_LIMITED_CRAFTING = register("doLimitedCrafting", Category.PLAYER, BooleanValue.create(false));
   
-  public static final Key<IntegerValue> RULE_MAX_COMMAND_CHAIN_LENGTH = register("maxCommandChainLength", Category.MISC, IntegerValue.access$100(65536));
+  public static final Key<IntegerValue> RULE_MAX_COMMAND_CHAIN_LENGTH = register("maxCommandChainLength", Category.MISC, IntegerValue.create(65536));
   
-  public static final Key<BooleanValue> RULE_ANNOUNCE_ADVANCEMENTS = register("announceAdvancements", Category.CHAT, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_ANNOUNCE_ADVANCEMENTS = register("announceAdvancements", Category.CHAT, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_DISABLE_RAIDS = register("disableRaids", Category.MOBS, BooleanValue.access$000(false));
+  public static final Key<BooleanValue> RULE_DISABLE_RAIDS = register("disableRaids", Category.MOBS, BooleanValue.create(false));
   
-  public static final Key<BooleanValue> RULE_DOINSOMNIA = register("doInsomnia", Category.SPAWNING, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_DOINSOMNIA = register("doInsomnia", Category.SPAWNING, BooleanValue.create(true));
   
   public static final Key<BooleanValue> RULE_DO_IMMEDIATE_RESPAWN;
   
   static {
-    RULE_DO_IMMEDIATE_RESPAWN = register("doImmediateRespawn", Category.PLAYER, BooleanValue.access$200(false, (debug0, debug1) -> {
+    RULE_DO_IMMEDIATE_RESPAWN = register("doImmediateRespawn", Category.PLAYER, BooleanValue.create(false, (debug0, debug1) -> {
             for (ServerPlayer debug3 : debug0.getPlayerList().getPlayers())
               debug3.connection.send((Packet)new ClientboundGameEventPacket(ClientboundGameEventPacket.IMMEDIATE_RESPAWN, debug1.get() ? 1.0F : 0.0F)); 
           }));
   }
   
-  public static final Key<BooleanValue> RULE_DROWNING_DAMAGE = register("drowningDamage", Category.PLAYER, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_DROWNING_DAMAGE = register("drowningDamage", Category.PLAYER, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_FALL_DAMAGE = register("fallDamage", Category.PLAYER, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_FALL_DAMAGE = register("fallDamage", Category.PLAYER, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_FIRE_DAMAGE = register("fireDamage", Category.PLAYER, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_FIRE_DAMAGE = register("fireDamage", Category.PLAYER, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_DO_PATROL_SPAWNING = register("doPatrolSpawning", Category.SPAWNING, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_DO_PATROL_SPAWNING = register("doPatrolSpawning", Category.SPAWNING, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_DO_TRADER_SPAWNING = register("doTraderSpawning", Category.SPAWNING, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_DO_TRADER_SPAWNING = register("doTraderSpawning", Category.SPAWNING, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_FORGIVE_DEAD_PLAYERS = register("forgiveDeadPlayers", Category.MOBS, BooleanValue.access$000(true));
+  public static final Key<BooleanValue> RULE_FORGIVE_DEAD_PLAYERS = register("forgiveDeadPlayers", Category.MOBS, BooleanValue.create(true));
   
-  public static final Key<BooleanValue> RULE_UNIVERSAL_ANGER = register("universalAnger", Category.MOBS, BooleanValue.access$000(false));
+  public static final Key<BooleanValue> RULE_UNIVERSAL_ANGER = register("universalAnger", Category.MOBS, BooleanValue.create(false));
   
   private final Map<Key<?>, Value<?>> rules;
   
@@ -122,7 +155,7 @@ public class GameRules {
   }
   
   public GameRules() {
-    this.rules = (Map<Key<?>, Value<?>>)GAME_RULE_TYPES.entrySet().stream().collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, debug0 -> ((Type)debug0.getValue()).createRule()));
+    this.rules = (Map<Key<?>, Value<?>>)(Object)GAME_RULE_TYPES.entrySet().stream().collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, debug0 -> ((Type)debug0.getValue()).createRule())); // MagmaCube - decompile fix
   }
   
   private GameRules(Map<Key<?>, Value<?>> debug1) {
@@ -135,16 +168,28 @@ public class GameRules {
   
   public CompoundTag createTag() {
     CompoundTag debug1 = new CompoundTag();
-    this.rules.forEach((debug1, debug2) -> debug0.putString(Key.access$600(debug1), debug2.serialize()));
+    this.rules.forEach((debug12, debug2) -> debug1.putString(debug12.id, debug2.serialize())); // MagmaCube - decompile fix
     return debug1;
   }
   
   private void loadFromTag(DynamicLike<?> debug1) {
-    this.rules.forEach((debug1, debug2) -> debug0.get(Key.access$600(debug1)).asString().result().ifPresent(debug2::deserialize));
+    this.rules.forEach((debug12, debug2) -> debug1.get(debug12.getId()).asString().result().ifPresent(debug2::deserialize)); // MagmaCube - decompile fix
   }
   
   public GameRules copy() {
-    return new GameRules((Map<Key<?>, Value<?>>)this.rules.entrySet().stream().collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, debug0 -> ((Value)debug0.getValue()).copy())));
+    return new GameRules((Map<Key<?>, Value<?>>)(Object)this.rules.entrySet().stream().collect(ImmutableMap.toImmutableMap(Map.Entry::getKey, debug0 -> ((Value)debug0.getValue()).copy()))); // MagmaCube - decompile fix
+  }
+
+  static interface VisitorCaller<T extends Value<T>> {
+    void call(GameRules.GameRuleTypeVisitor param1GameRuleTypeVisitor, GameRules.Key<T> param1Key, GameRules.Type<T> param1Type);
+  }
+
+  public static interface GameRuleTypeVisitor {
+    default <T extends GameRules.Value<T>> void visit(GameRules.Key<T> debug1, GameRules.Type<T> debug2) {}
+
+    default void visitBoolean(GameRules.Key<GameRules.BooleanValue> debug1, GameRules.Type<GameRules.BooleanValue> debug2) {}
+
+    default void visitInteger(GameRules.Key<GameRules.IntegerValue> debug1, GameRules.Type<GameRules.IntegerValue> debug2) {}
   }
   
   public static void visitGameRuleTypes(GameRuleTypeVisitor debug0) {
@@ -164,7 +209,7 @@ public class GameRules {
   
   private <T extends Value<T>> void assignCap(Key<T> debug1, GameRules debug2, @Nullable MinecraftServer debug3) {
     T debug4 = debug2.getRule(debug1);
-    getRule(debug1).setFrom((Value)debug4, debug3);
+    getRule(debug1).setFrom((T) debug4, debug3);
   }
   
   public boolean getBoolean(Key<BooleanValue> debug1) {
@@ -174,4 +219,232 @@ public class GameRules {
   public int getInt(Key<IntegerValue> debug1) {
     return ((IntegerValue)getRule(debug1)).get();
   }
+
+  public static final class Key<T extends Value<T>> {
+    private final String id;
+
+    private final GameRules.Category category;
+
+    public Key(String debug1, GameRules.Category debug2) {
+      this.id = debug1;
+      this.category = debug2;
+    }
+
+    public String toString() {
+      return this.id;
+    }
+
+    public boolean equals(Object debug1) {
+      if (this == debug1)
+        return true;
+      return (debug1 instanceof Key && ((Key)debug1).id.equals(this.id));
+    }
+
+    public int hashCode() {
+      return this.id.hashCode();
+    }
+
+    public String getId() {
+      return this.id;
+    }
+
+    public String getDescriptionId() {
+      return "gamerule." + this.id;
+    }
+
+    public GameRules.Category getCategory() {
+      return this.category;
+    }
+  }
+
+  public static class Type<T extends Value<T>> {
+    private final Supplier<ArgumentType<?>> argument;
+
+    private final Function<Type<T>, T> constructor;
+
+    private final BiConsumer<MinecraftServer, T> callback;
+
+    private final GameRules.VisitorCaller<T> visitorCaller;
+
+    private Type(Supplier<ArgumentType<?>> debug1, Function<Type<T>, T> debug2, BiConsumer<MinecraftServer, T> debug3, GameRules.VisitorCaller<T> debug4) {
+      this.argument = debug1;
+      this.constructor = debug2;
+      this.callback = debug3;
+      this.visitorCaller = debug4;
+    }
+
+    public RequiredArgumentBuilder<CommandSourceStack, ?> createArgument(String debug1) {
+      return Commands.argument(debug1, this.argument.get());
+    }
+
+    public T createRule() {
+      return this.constructor.apply(this);
+    }
+
+    public void callVisitor(GameRules.GameRuleTypeVisitor debug1, GameRules.Key<T> debug2) {
+      this.visitorCaller.call(debug1, debug2, this);
+    }
+  }
+
+  public static abstract class Value<T extends Value<T>> {
+    protected final GameRules.Type<T> type;
+
+    public Value(GameRules.Type<T> debug1) {
+      this.type = debug1;
+    }
+
+    protected abstract void updateFromArgument(CommandContext<CommandSourceStack> param1CommandContext, String param1String);
+
+    public void setFromArgument(CommandContext<CommandSourceStack> debug1, String debug2) {
+      updateFromArgument(debug1, debug2);
+      onChanged(((CommandSourceStack)debug1.getSource()).getServer());
+    }
+
+    protected void onChanged(@Nullable MinecraftServer debug1) {
+      if (debug1 != null)
+        this.type.callback.accept(debug1, getSelf());
+    }
+
+    protected abstract void deserialize(String param1String);
+
+    public abstract String serialize();
+
+    public String toString() {
+      return serialize();
+    }
+
+    public abstract int getCommandResult();
+
+    protected abstract T getSelf();
+
+    protected abstract T copy();
+
+    public abstract void setFrom(T param1T, @Nullable MinecraftServer param1MinecraftServer);
+  }
+
+  public static class IntegerValue extends Value<IntegerValue> {
+    private int value;
+
+    private static GameRules.Type<IntegerValue> create(int debug0, BiConsumer<MinecraftServer, IntegerValue> debug1) {
+      return new GameRules.Type<>(IntegerArgumentType::integer, debug21 -> new IntegerValue(debug21, debug0), debug1, GameRules.GameRuleTypeVisitor::visitInteger);
+    }
+
+    private static GameRules.Type<IntegerValue> create(int debug0) {
+      return create(debug0, (debug20, debug1) -> {
+      });
+    }
+
+    public IntegerValue(GameRules.Type<IntegerValue> debug1, int debug2) {
+      super(debug1);
+      this.value = debug2;
+    }
+
+    protected void updateFromArgument(CommandContext<CommandSourceStack> debug1, String debug2) {
+      this.value = IntegerArgumentType.getInteger(debug1, debug2);
+    }
+
+    public int get() {
+      return this.value;
+    }
+
+    public String serialize() {
+      return Integer.toString(this.value);
+    }
+
+    protected void deserialize(String debug1) {
+      this.value = safeParse(debug1);
+    }
+
+    public boolean tryDeserialize(String debug1) {
+      try {
+        this.value = Integer.parseInt(debug1);
+        return true;
+      } catch (NumberFormatException numberFormatException) {
+        return false;
+      }
+    }
+
+    private static int safeParse(String debug0) {
+      if (!debug0.isEmpty())
+        try {
+          return Integer.parseInt(debug0);
+        } catch (NumberFormatException debug1) {
+          GameRules.LOGGER.warn("Failed to parse integer {}", debug0);
+        }
+      return 0;
+    }
+
+    public int getCommandResult() {
+      return this.value;
+    }
+
+    protected IntegerValue getSelf() {
+      return this;
+    }
+
+    protected IntegerValue copy() {
+      return new IntegerValue(this.type, this.value);
+    }
+
+    public void setFrom(IntegerValue debug1, @Nullable MinecraftServer debug2) {
+      this.value = debug1.value;
+      onChanged(debug2);
+    }
+  }
+
+  public static class BooleanValue extends Value<BooleanValue> {
+    private boolean value;
+
+    private static GameRules.Type<BooleanValue> create(boolean debug0, BiConsumer<MinecraftServer, BooleanValue> debug1) {
+      return new GameRules.Type<>(BoolArgumentType::bool, debug12 -> new BooleanValue(debug12, debug0), debug1, GameRules.GameRuleTypeVisitor::visitBoolean);
+    }
+
+    private static GameRules.Type<BooleanValue> create(boolean debug0) {
+      return create(debug0, (debug02, debug1) -> {
+      });
+    }
+
+    public BooleanValue(GameRules.Type<BooleanValue> debug1, boolean debug2) {
+      super(debug1);
+      this.value = debug2;
+    }
+
+    protected void updateFromArgument(CommandContext<CommandSourceStack> debug1, String debug2) {
+      this.value = BoolArgumentType.getBool(debug1, debug2);
+    }
+
+    public boolean get() {
+      return this.value;
+    }
+
+    public void set(boolean debug1, @Nullable MinecraftServer debug2) {
+      this.value = debug1;
+      onChanged(debug2);
+    }
+
+    public String serialize() {
+      return Boolean.toString(this.value);
+    }
+
+    protected void deserialize(String debug1) {
+      this.value = Boolean.parseBoolean(debug1);
+    }
+
+    public int getCommandResult() {
+      return this.value ? 1 : 0;
+    }
+
+    protected BooleanValue getSelf() {
+      return this;
+    }
+
+    protected BooleanValue copy() {
+      return new BooleanValue(this.type, this.value);
+    }
+
+    public void setFrom(BooleanValue debug1, @Nullable MinecraftServer debug2) {
+      this.value = debug1.value;
+      onChanged(debug2);
+    }
+  }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index c87a003d8bbb2b418843b427d33ce53ed2b4ffc6..546518fd3ba56a8af105fd0b7665ea915e619da0 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -1,9 +1,16 @@
 package net.minecraft.world.level.block.state;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Random;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.function.ToIntFunction;
 import javax.annotation.Nullable;
+
+import com.google.common.collect.ImmutableMap;
+import com.mojang.serialization.MapCodec;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Registry;
@@ -18,12 +25,15 @@ import net.minecraft.world.InteractionHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.MenuProvider;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.entity.projectile.Projectile;
+import net.minecraft.world.item.DyeColor;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.context.BlockPlaceContext;
 import net.minecraft.world.level.BlockGetter;
+import net.minecraft.world.level.EmptyBlockGetter;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.LevelReader;
@@ -32,6 +42,8 @@ import net.minecraft.world.level.block.Mirror;
 import net.minecraft.world.level.block.RenderShape;
 import net.minecraft.world.level.block.Rotation;
 import net.minecraft.world.level.block.SoundType;
+import net.minecraft.world.level.block.SupportType;
+import net.minecraft.world.level.block.state.properties.Property;
 import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.Fluids;
@@ -45,6 +57,7 @@ import net.minecraft.world.level.storage.loot.LootTable;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParamSets;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParams;
 import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
@@ -76,16 +89,16 @@ public abstract class BlockBehaviour {
   protected ResourceLocation drops;
   
   public BlockBehaviour(Properties debug1) {
-    this.material = Properties.access$000(debug1);
-    this.hasCollision = Properties.access$100(debug1);
-    this.drops = Properties.access$200(debug1);
-    this.explosionResistance = Properties.access$300(debug1);
-    this.isRandomlyTicking = Properties.access$400(debug1);
-    this.soundType = Properties.access$500(debug1);
-    this.friction = Properties.access$600(debug1);
-    this.speedFactor = Properties.access$700(debug1);
-    this.jumpFactor = Properties.access$800(debug1);
-    this.dynamicShape = Properties.access$900(debug1);
+    this.material = debug1.material;
+    this.hasCollision = debug1.hasCollision;
+    this.drops = debug1.drops;
+    this.explosionResistance = debug1.explosionResistance;
+    this.isRandomlyTicking = debug1.isRandomlyTicking;
+    this.soundType = debug1.soundType;
+    this.friction = debug1.friction;
+    this.speedFactor = debug1.speedFactor;
+    this.jumpFactor = debug1.jumpFactor;
+    this.dynamicShape = debug1.dynamicShape;
     this.properties = debug1;
   }
   
@@ -94,7 +107,7 @@ public abstract class BlockBehaviour {
   
   @Deprecated
   public boolean isPathfindable(BlockState debug1, BlockGetter debug2, BlockPos debug3, PathComputationType debug4) {
-    switch (null.$SwitchMap$net$minecraft$world$level$pathfinder$PathComputationType[debug4.ordinal()]) {
+    switch (debug4.ordinal()) {
       case 1:
         return !debug1.isCollisionShapeFullBlock(debug2, debug3);
       case 2:
@@ -321,8 +334,671 @@ public abstract class BlockBehaviour {
   public abstract Item asItem();
   
   protected abstract Block asBlock();
+
+  // MagmaCube start - decompile fix
+  public enum OffsetType {
+    NONE, XZ, XYZ;
+  }
   
   public MaterialColor defaultMaterialColor() {
-    return Properties.access$1000(this.properties).apply(asBlock().defaultBlockState());
+    return this.properties.materialColor.apply(asBlock().defaultBlockState());
+  }
+
+  public static class Properties {
+    private Material material;
+
+    private Function<BlockState, MaterialColor> materialColor;
+
+    private boolean hasCollision = true;
+
+    private SoundType soundType = SoundType.STONE;
+
+    private ToIntFunction<BlockState> lightEmission = debug0 -> 0;
+
+    private float explosionResistance;
+
+    private float destroyTime;
+
+    private boolean requiresCorrectToolForDrops;
+
+    private boolean isRandomlyTicking;
+
+    private float friction = 0.6F;
+
+    private float speedFactor = 1.0F;
+
+    private float jumpFactor = 1.0F;
+
+    private ResourceLocation drops;
+
+    private boolean canOcclude = true;
+
+    private boolean isAir;
+
+    private BlockBehaviour.StateArgumentPredicate<EntityType<?>> isValidSpawn;
+
+    private BlockBehaviour.StatePredicate isRedstoneConductor;
+
+    private BlockBehaviour.StatePredicate isSuffocating;
+
+    private BlockBehaviour.StatePredicate isViewBlocking;
+
+    private BlockBehaviour.StatePredicate hasPostProcess;
+
+    private BlockBehaviour.StatePredicate emissiveRendering;
+
+    private boolean dynamicShape;
+
+    private Properties(Material debug1, Function<BlockState, MaterialColor> debug2) {
+      this.isValidSpawn = ((debug0, debug12, debug22, debug3) ->
+              (debug0.isFaceSturdy(debug12, debug22, Direction.UP) && debug0.getLightEmission() < 14));
+      this.isRedstoneConductor = ((debug0, debug12, debug22) ->
+              (debug0.getMaterial().isSolidBlocking() && debug0.isCollisionShapeFullBlock(debug12, debug22)));
+      this.isSuffocating = ((debug12, debug22, debug3) ->
+              (this.material.blocksMotion() && debug12.isCollisionShapeFullBlock(debug22, debug3)));
+      this.isViewBlocking = this.isSuffocating;
+      this.hasPostProcess = ((debug0, debug12, debug22) -> false);
+      this.emissiveRendering = ((debug0, debug21, debug22) -> false);
+      this.material = debug1;
+      this.materialColor = debug2;
+    }
+
+    private Properties(Material debug1, MaterialColor debug2) {
+      this(debug1, debug12 -> debug2);
+    }
+
+    public static Properties of(Material debug0) {
+      return of(debug0, debug0.getColor());
+    }
+
+    public static Properties of(Material debug0, DyeColor debug1) {
+      return of(debug0, debug1.getMaterialColor());
+    }
+
+    public static Properties of(Material debug0, MaterialColor debug1) {
+      return new Properties(debug0, debug1);
+    }
+
+    public static Properties of(Material debug0, Function<BlockState, MaterialColor> debug1) {
+      return new Properties(debug0, debug1);
+    }
+
+    public static Properties copy(BlockBehaviour debug0) {
+      Properties debug1 = new Properties(debug0.material, debug0.properties.materialColor);
+      debug1.material = debug0.properties.material;
+      debug1.destroyTime = debug0.properties.destroyTime;
+      debug1.explosionResistance = debug0.properties.explosionResistance;
+      debug1.hasCollision = debug0.properties.hasCollision;
+      debug1.isRandomlyTicking = debug0.properties.isRandomlyTicking;
+      debug1.lightEmission = debug0.properties.lightEmission;
+      debug1.materialColor = debug0.properties.materialColor;
+      debug1.soundType = debug0.properties.soundType;
+      debug1.friction = debug0.properties.friction;
+      debug1.speedFactor = debug0.properties.speedFactor;
+      debug1.dynamicShape = debug0.properties.dynamicShape;
+      debug1.canOcclude = debug0.properties.canOcclude;
+      debug1.isAir = debug0.properties.isAir;
+      debug1.requiresCorrectToolForDrops = debug0.properties.requiresCorrectToolForDrops;
+      return debug1;
+    }
+
+    public Properties noCollission() {
+      this.hasCollision = false;
+      this.canOcclude = false;
+      return this;
+    }
+
+    public Properties noOcclusion() {
+      this.canOcclude = false;
+      return this;
+    }
+
+    public Properties friction(float debug1) {
+      this.friction = debug1;
+      return this;
+    }
+
+    public Properties speedFactor(float debug1) {
+      this.speedFactor = debug1;
+      return this;
+    }
+
+    public Properties jumpFactor(float debug1) {
+      this.jumpFactor = debug1;
+      return this;
+    }
+
+    public Properties sound(SoundType debug1) {
+      this.soundType = debug1;
+      return this;
+    }
+
+    public Properties lightLevel(ToIntFunction<BlockState> debug1) {
+      this.lightEmission = debug1;
+      return this;
+    }
+
+    public Properties strength(float debug1, float debug2) {
+      this.destroyTime = debug1;
+      this.explosionResistance = Math.max(0.0F, debug2);
+      return this;
+    }
+
+    public Properties instabreak() {
+      return strength(0.0F);
+    }
+
+    public Properties strength(float debug1) {
+      strength(debug1, debug1);
+      return this;
+    }
+
+    public Properties randomTicks() {
+      this.isRandomlyTicking = true;
+      return this;
+    }
+
+    public Properties dynamicShape() {
+      this.dynamicShape = true;
+      return this;
+    }
+
+    public Properties noDrops() {
+      this.drops = BuiltInLootTables.EMPTY;
+      return this;
+    }
+
+    public Properties dropsLike(Block debug1) {
+      this.drops = debug1.getLootTable();
+      return this;
+    }
+
+    public Properties air() {
+      this.isAir = true;
+      return this;
+    }
+
+    public Properties isValidSpawn(BlockBehaviour.StateArgumentPredicate<EntityType<?>> debug1) {
+      this.isValidSpawn = debug1;
+      return this;
+    }
+
+    public Properties isRedstoneConductor(BlockBehaviour.StatePredicate debug1) {
+      this.isRedstoneConductor = debug1;
+      return this;
+    }
+
+    public Properties isSuffocating(BlockBehaviour.StatePredicate debug1) {
+      this.isSuffocating = debug1;
+      return this;
+    }
+
+    public Properties isViewBlocking(BlockBehaviour.StatePredicate debug1) {
+      this.isViewBlocking = debug1;
+      return this;
+    }
+
+    public Properties hasPostProcess(BlockBehaviour.StatePredicate debug1) {
+      this.hasPostProcess = debug1;
+      return this;
+    }
+
+    public Properties emissiveRendering(BlockBehaviour.StatePredicate debug1) {
+      this.emissiveRendering = debug1;
+      return this;
+    }
+
+    public Properties requiresCorrectToolForDrops() {
+      this.requiresCorrectToolForDrops = true;
+      return this;
+    }
+  }
+
+  public static abstract class BlockStateBase extends StateHolder<Block, BlockState> {
+    private final int lightEmission;
+
+    private final boolean useShapeForLightOcclusion;
+
+    private final boolean isAir;
+
+    private final Material material;
+
+    private final MaterialColor materialColor;
+
+    private final float destroySpeed;
+
+    private final boolean requiresCorrectToolForDrops;
+
+    private final boolean canOcclude;
+
+    private final BlockBehaviour.StatePredicate isRedstoneConductor;
+
+    private final BlockBehaviour.StatePredicate isSuffocating;
+
+    private final BlockBehaviour.StatePredicate isViewBlocking;
+
+    private final BlockBehaviour.StatePredicate hasPostProcess;
+
+    private final BlockBehaviour.StatePredicate emissiveRendering;
+
+    @Nullable
+    protected Cache cache;
+
+    protected BlockStateBase(Block debug1, ImmutableMap<Property<?>, Comparable<?>> debug2, MapCodec<BlockState> debug3) {
+      super(debug1, debug2, debug3);
+      BlockBehaviour.Properties debug4 = debug1.properties;
+      this.lightEmission = debug4.lightEmission.applyAsInt(asState());
+      this.useShapeForLightOcclusion = debug1.useShapeForLightOcclusion(asState());
+      this.isAir = debug4.isAir;
+      this.material = debug4.material;
+      this.materialColor = debug4.materialColor.apply(asState());
+      this.destroySpeed = debug4.destroyTime;
+      this.requiresCorrectToolForDrops = debug4.requiresCorrectToolForDrops;
+      this.canOcclude = debug4.canOcclude;
+      this.isRedstoneConductor = debug4.isRedstoneConductor;
+      this.isSuffocating = debug4.isSuffocating;
+      this.isViewBlocking = debug4.isViewBlocking;
+      this.hasPostProcess = debug4.hasPostProcess;
+      this.emissiveRendering = debug4.emissiveRendering;
+    }
+
+    public void initCache() {
+      if (!getBlock().hasDynamicShape())
+        this.cache = new Cache(asState());
+    }
+
+    public Block getBlock() {
+      return this.owner;
+    }
+
+    public Material getMaterial() {
+      return this.material;
+    }
+
+    public boolean isValidSpawn(BlockGetter debug1, BlockPos debug2, EntityType<?> debug3) {
+      return (getBlock()).properties.isValidSpawn.test(asState(), debug1, debug2, debug3);
+    }
+
+    public boolean propagatesSkylightDown(BlockGetter debug1, BlockPos debug2) {
+      if (this.cache != null)
+        return this.cache.propagatesSkylightDown;
+      return getBlock().propagatesSkylightDown(asState(), debug1, debug2);
+    }
+
+    public int getLightBlock(BlockGetter debug1, BlockPos debug2) {
+      if (this.cache != null)
+        return this.cache.lightBlock;
+      return getBlock().getLightBlock(asState(), debug1, debug2);
+    }
+
+    public VoxelShape getFaceOcclusionShape(BlockGetter debug1, BlockPos debug2, Direction debug3) {
+      if (this.cache != null && this.cache.occlusionShapes != null)
+        return this.cache.occlusionShapes[debug3.ordinal()];
+      return Shapes.getFaceShape(getOcclusionShape(debug1, debug2), debug3);
+    }
+
+    public VoxelShape getOcclusionShape(BlockGetter debug1, BlockPos debug2) {
+      return getBlock().getOcclusionShape(asState(), debug1, debug2);
+    }
+
+    public boolean hasLargeCollisionShape() {
+      return (this.cache == null || this.cache.largeCollisionShape);
+    }
+
+    public boolean useShapeForLightOcclusion() {
+      return this.useShapeForLightOcclusion;
+    }
+
+    public int getLightEmission() {
+      return this.lightEmission;
+    }
+
+    public boolean isAir() {
+      return this.isAir;
+    }
+
+    public MaterialColor getMapColor(BlockGetter debug1, BlockPos debug2) {
+      return this.materialColor;
+    }
+
+    public BlockState rotate(Rotation debug1) {
+      return getBlock().rotate(asState(), debug1);
+    }
+
+    public BlockState mirror(Mirror debug1) {
+      return getBlock().mirror(asState(), debug1);
+    }
+
+    public RenderShape getRenderShape() {
+      return getBlock().getRenderShape(asState());
+    }
+
+    public boolean emissiveRendering(BlockGetter debug1, BlockPos debug2) {
+      return this.emissiveRendering.test(asState(), debug1, debug2);
+    }
+
+    public float getShadeBrightness(BlockGetter debug1, BlockPos debug2) {
+      return getBlock().getShadeBrightness(asState(), debug1, debug2);
+    }
+
+    public boolean isRedstoneConductor(BlockGetter debug1, BlockPos debug2) {
+      return this.isRedstoneConductor.test(asState(), debug1, debug2);
+    }
+
+    public boolean isSignalSource() {
+      return getBlock().isSignalSource(asState());
+    }
+
+    public int getSignal(BlockGetter debug1, BlockPos debug2, Direction debug3) {
+      return getBlock().getSignal(asState(), debug1, debug2, debug3);
+    }
+
+    public boolean hasAnalogOutputSignal() {
+      return getBlock().hasAnalogOutputSignal(asState());
+    }
+
+    public int getAnalogOutputSignal(Level debug1, BlockPos debug2) {
+      return getBlock().getAnalogOutputSignal(asState(), debug1, debug2);
+    }
+
+    public float getDestroySpeed(BlockGetter debug1, BlockPos debug2) {
+      return this.destroySpeed;
+    }
+
+    public float getDestroyProgress(Player debug1, BlockGetter debug2, BlockPos debug3) {
+      return getBlock().getDestroyProgress(asState(), debug1, debug2, debug3);
+    }
+
+    public int getDirectSignal(BlockGetter debug1, BlockPos debug2, Direction debug3) {
+      return getBlock().getDirectSignal(asState(), debug1, debug2, debug3);
+    }
+
+    public PushReaction getPistonPushReaction() {
+      return getBlock().getPistonPushReaction(asState());
+    }
+
+    public boolean isSolidRender(BlockGetter debug1, BlockPos debug2) {
+      if (this.cache != null)
+        return this.cache.solidRender;
+      BlockState debug3 = asState();
+      if (debug3.canOcclude())
+        return Block.isShapeFullBlock(debug3.getOcclusionShape(debug1, debug2));
+      return false;
+    }
+
+    public boolean canOcclude() {
+      return this.canOcclude;
+    }
+
+    public boolean skipRendering(BlockState debug1, Direction debug2) {
+      return getBlock().skipRendering(asState(), debug1, debug2);
+    }
+
+    public VoxelShape getShape(BlockGetter debug1, BlockPos debug2) {
+      return getShape(debug1, debug2, CollisionContext.empty());
+    }
+
+    public VoxelShape getShape(BlockGetter debug1, BlockPos debug2, CollisionContext debug3) {
+      return getBlock().getShape(asState(), debug1, debug2, debug3);
+    }
+
+    public VoxelShape getCollisionShape(BlockGetter debug1, BlockPos debug2) {
+      if (this.cache != null)
+        return this.cache.collisionShape;
+      return getCollisionShape(debug1, debug2, CollisionContext.empty());
+    }
+
+    public VoxelShape getCollisionShape(BlockGetter debug1, BlockPos debug2, CollisionContext debug3) {
+      return getBlock().getCollisionShape(asState(), debug1, debug2, debug3);
+    }
+
+    public VoxelShape getBlockSupportShape(BlockGetter debug1, BlockPos debug2) {
+      return getBlock().getBlockSupportShape(asState(), debug1, debug2);
+    }
+
+    public VoxelShape getVisualShape(BlockGetter debug1, BlockPos debug2, CollisionContext debug3) {
+      return getBlock().getVisualShape(asState(), debug1, debug2, debug3);
+    }
+
+    public VoxelShape getInteractionShape(BlockGetter debug1, BlockPos debug2) {
+      return getBlock().getInteractionShape(asState(), debug1, debug2);
+    }
+
+    public final boolean entityCanStandOn(BlockGetter debug1, BlockPos debug2, Entity debug3) {
+      return entityCanStandOnFace(debug1, debug2, debug3, Direction.UP);
+    }
+
+    public final boolean entityCanStandOnFace(BlockGetter debug1, BlockPos debug2, Entity debug3, Direction debug4) {
+      return Block.isFaceFull(getCollisionShape(debug1, debug2, CollisionContext.of(debug3)), debug4);
+    }
+
+    public Vec3 getOffset(BlockGetter debug1, BlockPos debug2) {
+      BlockBehaviour.OffsetType debug3 = getBlock().getOffsetType();
+      if (debug3 == BlockBehaviour.OffsetType.NONE)
+        return Vec3.ZERO;
+      long debug4 = Mth.getSeed(debug2.getX(), 0, debug2.getZ());
+      return new Vec3((((float)(debug4 & 0xFL) / 15.0F) - 0.5D) * 0.5D, (debug3 == BlockBehaviour.OffsetType.XYZ) ? ((((float)(debug4 >> 4L & 0xFL) / 15.0F) - 1.0D) * 0.2D) : 0.0D, (((float)(debug4 >> 8L & 0xFL) / 15.0F) - 0.5D) * 0.5D);
+    }
+
+    public boolean triggerEvent(Level debug1, BlockPos debug2, int debug3, int debug4) {
+      return getBlock().triggerEvent(asState(), debug1, debug2, debug3, debug4);
+    }
+
+    public void neighborChanged(Level debug1, BlockPos debug2, Block debug3, BlockPos debug4, boolean debug5) {
+      getBlock().neighborChanged(asState(), debug1, debug2, debug3, debug4, debug5);
+    }
+
+    public final void updateNeighbourShapes(LevelAccessor debug1, BlockPos debug2, int debug3) {
+      updateNeighbourShapes(debug1, debug2, debug3, 512);
+    }
+
+    public final void updateNeighbourShapes(LevelAccessor debug1, BlockPos debug2, int debug3, int debug4) {
+      getBlock();
+      BlockPos.MutableBlockPos debug5 = new BlockPos.MutableBlockPos();
+      for (Direction debug9 : BlockBehaviour.UPDATE_SHAPE_ORDER) {
+        debug5.setWithOffset((Vec3i)debug2, debug9);
+        BlockState debug10 = debug1.getBlockState((BlockPos)debug5);
+        BlockState debug11 = debug10.updateShape(debug9.getOpposite(), asState(), debug1, (BlockPos)debug5, debug2);
+        Block.updateOrDestroy(debug10, debug11, debug1, (BlockPos)debug5, debug3, debug4);
+      }
+    }
+
+    public final void updateIndirectNeighbourShapes(LevelAccessor debug1, BlockPos debug2, int debug3) {
+      updateIndirectNeighbourShapes(debug1, debug2, debug3, 512);
+    }
+
+    public void updateIndirectNeighbourShapes(LevelAccessor debug1, BlockPos debug2, int debug3, int debug4) {
+      getBlock().updateIndirectNeighbourShapes(asState(), debug1, debug2, debug3, debug4);
+    }
+
+    public void onPlace(Level debug1, BlockPos debug2, BlockState debug3, boolean debug4) {
+      getBlock().onPlace(asState(), debug1, debug2, debug3, debug4);
+    }
+
+    public void onRemove(Level debug1, BlockPos debug2, BlockState debug3, boolean debug4) {
+      getBlock().onRemove(asState(), debug1, debug2, debug3, debug4);
+    }
+
+    public void tick(ServerLevel debug1, BlockPos debug2, Random debug3) {
+      getBlock().tick(asState(), debug1, debug2, debug3);
+    }
+
+    public void randomTick(ServerLevel debug1, BlockPos debug2, Random debug3) {
+      getBlock().randomTick(asState(), debug1, debug2, debug3);
+    }
+
+    public void entityInside(Level debug1, BlockPos debug2, Entity debug3) {
+      getBlock().entityInside(asState(), debug1, debug2, debug3);
+    }
+
+    public void spawnAfterBreak(ServerLevel debug1, BlockPos debug2, ItemStack debug3) {
+      getBlock().spawnAfterBreak(asState(), debug1, debug2, debug3);
+    }
+
+    public List<ItemStack> getDrops(LootContext.Builder debug1) {
+      return getBlock().getDrops(asState(), debug1);
+    }
+
+    public InteractionResult use(Level debug1, Player debug2, InteractionHand debug3, BlockHitResult debug4) {
+      return getBlock().use(asState(), debug1, debug4.getBlockPos(), debug2, debug3, debug4);
+    }
+
+    public void attack(Level debug1, BlockPos debug2, Player debug3) {
+      getBlock().attack(asState(), debug1, debug2, debug3);
+    }
+
+    public boolean isSuffocating(BlockGetter debug1, BlockPos debug2) {
+      return this.isSuffocating.test(asState(), debug1, debug2);
+    }
+
+    public boolean isViewBlocking(BlockGetter debug1, BlockPos debug2) {
+      return this.isViewBlocking.test(asState(), debug1, debug2);
+    }
+
+    public BlockState updateShape(Direction debug1, BlockState debug2, LevelAccessor debug3, BlockPos debug4, BlockPos debug5) {
+      return getBlock().updateShape(asState(), debug1, debug2, debug3, debug4, debug5);
+    }
+
+    public boolean isPathfindable(BlockGetter debug1, BlockPos debug2, PathComputationType debug3) {
+      return getBlock().isPathfindable(asState(), debug1, debug2, debug3);
+    }
+
+    public boolean canBeReplaced(BlockPlaceContext debug1) {
+      return getBlock().canBeReplaced(asState(), debug1);
+    }
+
+    public boolean canBeReplaced(Fluid debug1) {
+      return getBlock().canBeReplaced(asState(), debug1);
+    }
+
+    public boolean canSurvive(LevelReader debug1, BlockPos debug2) {
+      return getBlock().canSurvive(asState(), debug1, debug2);
+    }
+
+    public boolean hasPostProcess(BlockGetter debug1, BlockPos debug2) {
+      return this.hasPostProcess.test(asState(), debug1, debug2);
+    }
+
+    @Nullable
+    public MenuProvider getMenuProvider(Level debug1, BlockPos debug2) {
+      return getBlock().getMenuProvider(asState(), debug1, debug2);
+    }
+
+    public boolean is(Tag<Block> debug1) {
+      return getBlock().is(debug1);
+    }
+
+    public boolean is(Tag<Block> debug1, Predicate<BlockStateBase> debug2) {
+      return (getBlock().is(debug1) && debug2.test(this));
+    }
+
+    public boolean is(Block debug1) {
+      return getBlock().is(debug1);
+    }
+
+    public FluidState getFluidState() {
+      return getBlock().getFluidState(asState());
+    }
+
+    public boolean isRandomlyTicking() {
+      return getBlock().isRandomlyTicking(asState());
+    }
+
+    public long getSeed(BlockPos debug1) {
+      return getBlock().getSeed(asState(), debug1);
+    }
+
+    public SoundType getSoundType() {
+      return getBlock().getSoundType(asState());
+    }
+
+    public void onProjectileHit(Level debug1, BlockState debug2, BlockHitResult debug3, Projectile debug4) {
+      getBlock().onProjectileHit(debug1, debug2, debug3, debug4);
+    }
+
+    public boolean isFaceSturdy(BlockGetter debug1, BlockPos debug2, Direction debug3) {
+      return isFaceSturdy(debug1, debug2, debug3, SupportType.FULL);
+    }
+
+    public boolean isFaceSturdy(BlockGetter debug1, BlockPos debug2, Direction debug3, SupportType debug4) {
+      if (this.cache != null)
+        return this.cache.isFaceSturdy(debug3, debug4);
+      return debug4.isSupporting(asState(), debug1, debug2, debug3);
+    }
+
+    public boolean isCollisionShapeFullBlock(BlockGetter debug1, BlockPos debug2) {
+      if (this.cache != null)
+        return this.cache.isCollisionShapeFullBlock;
+      return Block.isShapeFullBlock(getCollisionShape(debug1, debug2));
+    }
+
+    protected abstract BlockState asState();
+
+    public boolean requiresCorrectToolForDrops() {
+      return this.requiresCorrectToolForDrops;
+    }
+
+    static final class Cache {
+      private static final Direction[] DIRECTIONS = Direction.values();
+
+      private static final int SUPPORT_TYPE_COUNT = (SupportType.values()).length;
+
+      protected final boolean solidRender;
+
+      private final boolean propagatesSkylightDown;
+
+      private final int lightBlock;
+
+      @Nullable
+      private final VoxelShape[] occlusionShapes;
+
+      protected final VoxelShape collisionShape;
+
+      protected final boolean largeCollisionShape;
+
+      private final boolean[] faceSturdy;
+
+      protected final boolean isCollisionShapeFullBlock;
+
+      private Cache(BlockState debug1) {
+        Block debug2 = debug1.getBlock();
+        this.solidRender = debug1.isSolidRender((BlockGetter) EmptyBlockGetter.INSTANCE, BlockPos.ZERO);
+        this.propagatesSkylightDown = debug2.propagatesSkylightDown(debug1, (BlockGetter)EmptyBlockGetter.INSTANCE, BlockPos.ZERO);
+        this.lightBlock = debug2.getLightBlock(debug1, (BlockGetter)EmptyBlockGetter.INSTANCE, BlockPos.ZERO);
+        if (!debug1.canOcclude()) {
+          this.occlusionShapes = null;
+        } else {
+          this.occlusionShapes = new VoxelShape[DIRECTIONS.length];
+          VoxelShape debug3 = debug2.getOcclusionShape(debug1, (BlockGetter)EmptyBlockGetter.INSTANCE, BlockPos.ZERO);
+          for (Direction debug7 : DIRECTIONS)
+            this.occlusionShapes[debug7.ordinal()] = Shapes.getFaceShape(debug3, debug7);
+        }
+        this.collisionShape = debug2.getCollisionShape(debug1, (BlockGetter)EmptyBlockGetter.INSTANCE, BlockPos.ZERO, CollisionContext.empty());
+        this.largeCollisionShape = Arrays.<Direction.Axis>stream(Direction.Axis.values()).anyMatch(debug12 -> (this.collisionShape.min(debug12) < 0.0D || this.collisionShape.max(debug12) > 1.0D));
+        this.faceSturdy = new boolean[DIRECTIONS.length * SUPPORT_TYPE_COUNT];
+        for (Direction debug6 : DIRECTIONS) {
+          for (SupportType debug10 : SupportType.values())
+            this.faceSturdy[getFaceSupportIndex(debug6, debug10)] = debug10.isSupporting(debug1, (BlockGetter)EmptyBlockGetter.INSTANCE, BlockPos.ZERO, debug6);
+        }
+        this.isCollisionShapeFullBlock = Block.isShapeFullBlock(debug1.getCollisionShape((BlockGetter)EmptyBlockGetter.INSTANCE, BlockPos.ZERO));
+      }
+
+      public boolean isFaceSturdy(Direction debug1, SupportType debug2) {
+        return this.faceSturdy[getFaceSupportIndex(debug1, debug2)];
+      }
+
+      private static int getFaceSupportIndex(Direction debug0, SupportType debug1) {
+        return debug0.ordinal() * SUPPORT_TYPE_COUNT + debug1.ordinal();
+      }
+    }
+  }
+
+  public static interface StateArgumentPredicate<A> {
+    boolean test(BlockState param1BlockState, BlockGetter param1BlockGetter, BlockPos param1BlockPos, A param1A);
+  }
+
+  public static interface StatePredicate {
+    boolean test(BlockState param1BlockState, BlockGetter param1BlockGetter, BlockPos param1BlockPos);
   }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/world/level/block/state/properties/Property.java b/src/main/java/net/minecraft/world/level/block/state/properties/Property.java
index 9337ec81af6369857099add1972be8f46120a237..e8a6a0a8d3c624433f8718d37d25b5762a039c14 100644
--- a/src/main/java/net/minecraft/world/level/block/state/properties/Property.java
+++ b/src/main/java/net/minecraft/world/level/block/state/properties/Property.java
@@ -20,18 +20,18 @@ public abstract class Property<T extends Comparable<T>> {
   private final Codec<Value<T>> valueCodec;
   
   protected Property(String debug1, Class<T> debug2) {
-    this.codec = Codec.STRING.comapFlatMap(debug1 -> (DataResult)getValue(debug1).<DataResult>map(DataResult::success).orElseGet(()), this::getName);
+    this.codec = Codec.STRING.comapFlatMap(debug11 -> (DataResult)getValue(debug11).<DataResult>map(DataResult::success).orElseGet(null), this::getName); // MagmaCube - decompile fix // todo: make sure orElseGet(null) is safe
     this.valueCodec = this.codec.xmap(this::value, Value::value);
     this.clazz = debug2;
     this.name = debug1;
   }
   
   public Value<T> value(T debug1) {
-    return new Value(this, (Comparable)debug1, null);
+    return new Value(this, (Comparable)debug1); // MagmaCube - decompile fix
   }
   
   public Value<T> value(StateHolder<?, ?> debug1) {
-    return new Value(this, debug1.getValue(this), null);
+    return new Value(this, debug1.getValue(this)); // MagmaCube - decompile fix
   }
   
   public Stream<Value<T>> getAllValues() {
@@ -83,4 +83,46 @@ public abstract class Property<T extends Comparable<T>> {
   public abstract String getName(T paramT);
   
   public abstract Optional<T> getValue(String paramString);
+
+  // MagmaCube start - decompile fix
+  public static final class Value<T extends Comparable<T>> {
+    private final Property<T> property;
+
+    private final T value;
+
+    private Value(Property<T> debug1, T debug2) {
+      if (!debug1.getPossibleValues().contains(debug2))
+        throw new IllegalArgumentException("Value " + debug2 + " does not belong to property " + debug1);
+      this.property = debug1;
+      this.value = debug2;
+    }
+
+    public Property<T> getProperty() {
+      return this.property;
+    }
+
+    public T value() {
+      return this.value;
+    }
+
+    public String toString() {
+      return this.property.getName() + "=" + this.property.getName(this.value);
+    }
+
+    public boolean equals(Object debug1) {
+      if (this == debug1)
+        return true;
+      if (!(debug1 instanceof Value))
+        return false;
+      Value<?> debug2 = (Value)debug1;
+      return (this.property == debug2.property && this.value.equals(debug2.value));
+    }
+
+    public int hashCode() {
+      int debug1 = this.property.hashCode();
+      debug1 = 31 * debug1 + this.value.hashCode();
+      return debug1;
+    }
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/Heightmap.java b/src/main/java/net/minecraft/world/level/levelgen/Heightmap.java
index e7f0cf86744d3da0642c35e904338348571f8d55..4aca3caef4d7d2193c415175cb4fd6ca80abe1a5 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/Heightmap.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/Heightmap.java
@@ -1,15 +1,24 @@
 package net.minecraft.world.level.levelgen;
 
+import com.google.common.collect.Maps;
+import com.mojang.serialization.Codec;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectListIterator;
+
+import java.util.Map;
 import java.util.Set;
 import java.util.function.Predicate;
+
+import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.util.BitStorage;
+import net.minecraft.util.StringRepresentable;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkAccess;
 
+import javax.annotation.Nullable;
+
 public class Heightmap {
   private static final Predicate<BlockState> NOT_AIR;
   
@@ -19,17 +28,81 @@ public class Heightmap {
     NOT_AIR = (debug0 -> !debug0.isAir());
     MATERIAL_MOTION_BLOCKING = (debug0 -> debug0.getMaterial().blocksMotion());
   }
-  
+
+  // MagmaCube start - decompile fix
+  public enum Usage {
+    WORLDGEN, LIVE_WORLD, CLIENT;
+  }
+
+  public enum Types implements StringRepresentable {
+    WORLD_SURFACE_WG("WORLD_SURFACE_WG", Heightmap.Usage.WORLDGEN, Heightmap.NOT_AIR),
+    WORLD_SURFACE("WORLD_SURFACE", Heightmap.Usage.CLIENT, Heightmap.NOT_AIR),
+    OCEAN_FLOOR_WG("OCEAN_FLOOR_WG", Heightmap.Usage.WORLDGEN, Heightmap.MATERIAL_MOTION_BLOCKING),
+    OCEAN_FLOOR("OCEAN_FLOOR", Heightmap.Usage.LIVE_WORLD, Heightmap.MATERIAL_MOTION_BLOCKING),
+    MOTION_BLOCKING("MOTION_BLOCKING", Heightmap.Usage.LIVE_WORLD, Heightmap.MATERIAL_MOTION_BLOCKING),
+    MOTION_BLOCKING_NO_LEAVES("MOTION_BLOCKING_NO_LEAVES", Heightmap.Usage.LIVE_WORLD, Heightmap.MATERIAL_MOTION_BLOCKING);
+
+    public static final Codec<Types> CODEC;
+
+    private final String serializationKey;
+
+    private final Heightmap.Usage usage;
+
+    private final Predicate<BlockState> isOpaque;
+
+    private static final Map<String, Types> REVERSE_LOOKUP;
+
+    static {
+      CODEC = StringRepresentable.fromEnum(Types::values, Types::getFromKey);
+      REVERSE_LOOKUP = (Map<String, Types>) (Object) Util.make(Maps.newHashMap(), debug0 -> {
+        for (Types debug4 : values())
+          debug0.put(debug4.serializationKey, debug4);
+      });
+    }
+
+    Types(String debug3, Heightmap.Usage debug4, Predicate<BlockState> debug5) {
+      this.serializationKey = debug3;
+      this.usage = debug4;
+      this.isOpaque = debug5;
+    }
+
+    public String getSerializationKey() {
+      return this.serializationKey;
+    }
+
+    public boolean sendToClient() {
+      return (this.usage == Heightmap.Usage.CLIENT);
+    }
+
+    public boolean keepAfterWorldgen() {
+      return (this.usage != Heightmap.Usage.WORLDGEN);
+    }
+
+    @Nullable
+    public static Types getFromKey(String debug0) {
+      return REVERSE_LOOKUP.get(debug0);
+    }
+
+    public Predicate<BlockState> isOpaque() {
+      return this.isOpaque;
+    }
+
+    public String getSerializedName() {
+      return this.serializationKey;
+    }
+  }
+
   private final BitStorage data = new BitStorage(9, 256);
-  
+
   private final Predicate<BlockState> isOpaque;
-  
+
   private final ChunkAccess chunk;
-  
+
   public Heightmap(ChunkAccess debug1, Types debug2) {
     this.isOpaque = debug2.isOpaque();
     this.chunk = debug1;
   }
+  // MagmaCube end - decompile fix
   
   public static void primeHeightmaps(ChunkAccess debug0, Set<Types> debug1) {
     int debug2 = debug1.size();
diff --git a/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java b/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
index 8d6283ae03b57e4dab9414faea13032d644ab293..cba4431eb8f47c1cf2c033b4c4d8fda58f4f03ee 100644
--- a/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
+++ b/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
@@ -2,6 +2,7 @@ package net.minecraft.world.level.storage;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
@@ -9,33 +10,49 @@ import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.DynamicOps;
 import com.mojang.serialization.Lifecycle;
+
+import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.IOException;
+import java.nio.file.FileVisitResult;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.SimpleFileVisitor;
+import java.nio.file.attribute.BasicFileAttributes;
 import java.nio.file.attribute.FileAttribute;
+import java.time.LocalDateTime;
 import java.time.format.DateTimeFormatter;
 import java.time.format.DateTimeFormatterBuilder;
 import java.time.format.SignStyle;
 import java.time.temporal.ChronoField;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 import java.util.function.BiFunction;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
 import javax.annotation.Nullable;
+
+import net.minecraft.FileUtil;
 import net.minecraft.SharedConstants;
 import net.minecraft.Util;
 import net.minecraft.core.Registry;
+import net.minecraft.core.RegistryAccess;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtIo;
 import net.minecraft.nbt.NbtOps;
 import net.minecraft.nbt.Tag;
 import net.minecraft.network.chat.TranslatableComponent;
 import net.minecraft.resources.RegistryLookupCodec;
+import net.minecraft.resources.ResourceKey;
 import net.minecraft.util.DirectoryLock;
+import net.minecraft.util.ProgressListener;
 import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.util.datafix.DataFixers;
 import net.minecraft.util.datafix.fixes.References;
 import net.minecraft.world.level.DataPackConfig;
+import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelSettings;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.dimension.DimensionType;
@@ -95,10 +112,10 @@ public class LevelStorageSource {
     Dynamic<T> debug4 = debug1.update(References.WORLD_GEN_SETTINGS, debug3, debug2, SharedConstants.getCurrentVersion().getWorldVersion());
     DataResult<WorldGenSettings> debug5 = WorldGenSettings.CODEC.parse(debug4);
     return Pair.of(debug5.resultOrPartial(Util.prefix("WorldGenSettings: ", LOGGER::error)).orElseGet(() -> {
-            Registry<DimensionType> debug1 = (Registry<DimensionType>)RegistryLookupCodec.create(Registry.DIMENSION_TYPE_REGISTRY).codec().parse(debug0).resultOrPartial(Util.prefix("Dimension type registry: ", LOGGER::error)).orElseThrow(());
-            Registry<Biome> debug2 = (Registry<Biome>)RegistryLookupCodec.create(Registry.BIOME_REGISTRY).codec().parse(debug0).resultOrPartial(Util.prefix("Biome registry: ", LOGGER::error)).orElseThrow(());
-            Registry<NoiseGeneratorSettings> debug3 = (Registry<NoiseGeneratorSettings>)RegistryLookupCodec.create(Registry.NOISE_GENERATOR_SETTINGS_REGISTRY).codec().parse(debug0).resultOrPartial(Util.prefix("Noise settings registry: ", LOGGER::error)).orElseThrow(());
-            return WorldGenSettings.makeDefault(debug1, debug2, debug3);
+            Registry<DimensionType> debug12 = (Registry<DimensionType>)RegistryLookupCodec.create(Registry.DIMENSION_TYPE_REGISTRY).codec().parse(debug0).resultOrPartial(Util.prefix("Dimension type registry: ", LOGGER::error)).orElseThrow(null);
+            Registry<Biome> debug22 = (Registry<Biome>)RegistryLookupCodec.create(Registry.BIOME_REGISTRY).codec().parse(debug0).resultOrPartial(Util.prefix("Biome registry: ", LOGGER::error)).orElseThrow(null);
+            Registry<NoiseGeneratorSettings> debug32 = (Registry<NoiseGeneratorSettings>)RegistryLookupCodec.create(Registry.NOISE_GENERATOR_SETTINGS_REGISTRY).codec().parse(debug0).resultOrPartial(Util.prefix("Noise settings registry: ", LOGGER::error)).orElseThrow(null);
+            return WorldGenSettings.makeDefault(debug12, debug22, debug32);
           }), debug5
 
 
@@ -118,7 +135,7 @@ public class LevelStorageSource {
     File[] debug2 = this.baseDir.toFile().listFiles();
     for (File debug6 : debug2) {
       if (debug6.isDirectory()) {
-        boolean debug7;
+        boolean debug7 = false;
         try {
           debug7 = DirectoryLock.isLocked(debug6.toPath());
         } catch (Exception exception) {
@@ -238,4 +255,183 @@ public class LevelStorageSource {
   public LevelStorageAccess createAccess(String debug1) throws IOException {
     return new LevelStorageAccess(this, debug1);
   }
+
+  // MagmaCube start - decompile fix
+  public class LevelStorageAccess implements AutoCloseable {
+    private final DirectoryLock lock;
+
+    private final Path levelPath;
+
+    private final String levelId;
+
+    private final Map<LevelResource, Path> resources = Maps.newHashMap();
+
+    public LevelStorageAccess(LevelStorageSource debug1, String debug2) throws IOException {
+      this.levelId = debug2;
+      this.levelPath = debug1.baseDir.resolve(debug2);
+      this.lock = DirectoryLock.create(this.levelPath);
+    }
+
+    public String getLevelId() {
+      return this.levelId;
+    }
+
+    public Path getLevelPath(LevelResource debug1) {
+      return this.resources.computeIfAbsent(debug1, debug12 -> this.levelPath.resolve(debug1.getId()));
+    }
+
+    public File getDimensionPath(ResourceKey<Level> debug1) {
+      return DimensionType.getStorageFolder(debug1, this.levelPath.toFile());
+    }
+
+    private void checkLock() {
+      if (!this.lock.isValid())
+        throw new IllegalStateException("Lock is no longer valid");
+    }
+
+    public PlayerDataStorage createPlayerStorage() {
+      checkLock();
+      return new PlayerDataStorage(this, LevelStorageSource.this.fixerUpper);
+    }
+
+    public boolean requiresConversion() {
+      LevelSummary debug1 = getSummary();
+      return (debug1 != null && debug1.levelVersion().levelDataVersion() != LevelStorageSource.this.getStorageVersion());
+    }
+
+    public boolean convertLevel(ProgressListener debug1) {
+      checkLock();
+      return McRegionUpgrader.convertLevel(this, debug1);
+    }
+
+    @Nullable
+    public LevelSummary getSummary() {
+      checkLock();
+      return (LevelSummary)LevelStorageSource.this.readLevelData(this.levelPath.toFile(), (BiFunction)LevelStorageSource.this.levelSummaryReader(this.levelPath.toFile(), false));
+    }
+
+    @Nullable
+    public WorldData getDataTag(DynamicOps<Tag> debug1, DataPackConfig debug2) {
+      checkLock();
+      return (WorldData)LevelStorageSource.this.readLevelData(this.levelPath.toFile(), (BiFunction)LevelStorageSource.getLevelData(debug1, debug2));
+    }
+
+    @Nullable
+    public DataPackConfig getDataPacks() {
+      checkLock();
+      return (DataPackConfig)LevelStorageSource.this.readLevelData(this.levelPath.toFile(), (debug0, debug1) -> LevelStorageSource.getDataPacks(debug0, debug1));
+    }
+
+    public void saveDataTag(RegistryAccess debug1, WorldData debug2) {
+      saveDataTag(debug1, debug2, null);
+    }
+
+    public void saveDataTag(RegistryAccess debug1, WorldData debug2, @Nullable CompoundTag debug3) {
+      File debug4 = this.levelPath.toFile();
+      CompoundTag debug5 = debug2.createTag(debug1, debug3);
+      CompoundTag debug6 = new CompoundTag();
+      debug6.put("Data", (Tag)debug5);
+      try {
+        File debug7 = File.createTempFile("level", ".dat", debug4);
+        NbtIo.writeCompressed(debug6, debug7);
+        File debug8 = new File(debug4, "level.dat_old");
+        File debug9 = new File(debug4, "level.dat");
+        Util.safeReplaceFile(debug9, debug7, debug8);
+      } catch (Exception debug7) {
+        LevelStorageSource.LOGGER.error("Failed to save level {}", debug4, debug7);
+      }
+    }
+
+    public File getIconFile() {
+      checkLock();
+      return this.levelPath.resolve("icon.png").toFile();
+    }
+
+    public void deleteLevel() throws IOException {
+      checkLock();
+      final Path lockPath = this.levelPath.resolve("session.lock");
+      for (int debug2 = 1; debug2 <= 5; debug2++) {
+        LevelStorageSource.LOGGER.info("Attempt {}...", Integer.valueOf(debug2));
+        try {
+          Files.walkFileTree(this.levelPath, new SimpleFileVisitor<Path>() {
+            public FileVisitResult visitFile(Path debug1, BasicFileAttributes debug2) throws IOException {
+              if (!debug1.equals(lockPath)) {
+                LevelStorageSource.LOGGER.debug("Deleting {}", debug1);
+                Files.delete(debug1);
+              }
+              return FileVisitResult.CONTINUE;
+            }
+
+            public FileVisitResult postVisitDirectory(Path debug1, IOException debug2) throws IOException {
+              if (debug2 != null)
+                throw debug2;
+              if (debug1.equals(LevelStorageSource.LevelStorageAccess.this.levelPath)) {
+                LevelStorageSource.LevelStorageAccess.this.lock.close();
+                Files.deleteIfExists(lockPath);
+              }
+              Files.delete(debug1);
+              return FileVisitResult.CONTINUE;
+            }
+          });
+          break;
+        } catch (IOException debug3) {
+          if (debug2 < 5) {
+            LevelStorageSource.LOGGER.warn("Failed to delete {}", this.levelPath, debug3);
+            try {
+              Thread.sleep(500L);
+            } catch (InterruptedException interruptedException) {}
+          } else {
+            throw debug3;
+          }
+        }
+      }
+    }
+
+    public void renameLevel(String debug1) throws IOException {
+      checkLock();
+      File debug2 = new File(LevelStorageSource.this.baseDir.toFile(), this.levelId);
+      if (!debug2.exists())
+        return;
+      File debug3 = new File(debug2, "level.dat");
+      if (debug3.exists()) {
+        CompoundTag debug4 = NbtIo.readCompressed(debug3);
+        CompoundTag debug5 = debug4.getCompound("Data");
+        debug5.putString("LevelName", debug1);
+        NbtIo.writeCompressed(debug4, debug3);
+      }
+    }
+
+    public long makeWorldBackup() throws IOException {
+      checkLock();
+      String debug1 = LocalDateTime.now().format(LevelStorageSource.FORMATTER) + "_" + this.levelId;
+      Path debug2 = LevelStorageSource.this.getBackupPath();
+      try {
+        Files.createDirectories(Files.exists(debug2, new java.nio.file.LinkOption[0]) ? debug2.toRealPath(new java.nio.file.LinkOption[0]) : debug2, (FileAttribute<?>[])new FileAttribute[0]);
+      } catch (IOException iOException) {
+        throw new RuntimeException(iOException);
+      }
+      Path debug3 = debug2.resolve(FileUtil.findAvailableName(debug2, debug1, ".zip"));
+      try (ZipOutputStream stream = new ZipOutputStream(new BufferedOutputStream(Files.newOutputStream(debug3, new java.nio.file.OpenOption[0])))) {
+        final Path rootPath = Paths.get(this.levelId, new String[0]);
+        Files.walkFileTree(this.levelPath, new SimpleFileVisitor<Path>() {
+          public FileVisitResult visitFile(Path debug1, BasicFileAttributes debug2) throws IOException {
+            if (debug1.endsWith("session.lock"))
+              return FileVisitResult.CONTINUE;
+            String debug3 = rootPath.resolve(LevelStorageSource.LevelStorageAccess.this.levelPath.relativize(debug1)).toString().replace('\\', '/');
+            ZipEntry debug4 = new ZipEntry(debug3);
+            stream.putNextEntry(debug4);
+            com.google.common.io.Files.asByteSource(debug1.toFile()).copyTo(stream);
+            stream.closeEntry();
+            return FileVisitResult.CONTINUE;
+          }
+        });
+      }
+      return Files.size(debug3);
+    }
+
+    public void close() throws IOException {
+      this.lock.close();
+    }
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/world/level/storage/loot/LootContext.java b/src/main/java/net/minecraft/world/level/storage/loot/LootContext.java
index 99d37284893b92e79345d887ad722737004abc48..791d3cf9776ff5c0b15f20af5ebfbc3bee013a36 100644
--- a/src/main/java/net/minecraft/world/level/storage/loot/LootContext.java
+++ b/src/main/java/net/minecraft/world/level/storage/loot/LootContext.java
@@ -1,17 +1,28 @@
 package net.minecraft.world.level.storage.loot;
 
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+
+import java.io.IOException;
 import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import javax.annotation.Nullable;
+
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParam;
+import net.minecraft.world.level.storage.loot.parameters.LootContextParamSet;
+import net.minecraft.world.level.storage.loot.parameters.LootContextParams;
 import net.minecraft.world.level.storage.loot.predicates.LootItemCondition;
 
 public class LootContext {
@@ -93,4 +104,141 @@ public class LootContext {
   public ServerLevel getLevel() {
     return this.level;
   }
+
+  // MagmaCube start - decompile fix
+  @FunctionalInterface
+  public static interface DynamicDrop {
+    void add(LootContext param1LootContext, Consumer<ItemStack> param1Consumer);
+  }
+
+  public static class Builder {
+    private final ServerLevel level;
+
+    private final Map<LootContextParam<?>, Object> params = Maps.newIdentityHashMap();
+
+    private final Map<ResourceLocation, LootContext.DynamicDrop> dynamicDrops = Maps.newHashMap();
+
+    private Random random;
+
+    private float luck;
+
+    public Builder(ServerLevel debug1) {
+      this.level = debug1;
+    }
+
+    public Builder withRandom(Random debug1) {
+      this.random = debug1;
+      return this;
+    }
+
+    public Builder withOptionalRandomSeed(long debug1) {
+      if (debug1 != 0L)
+        this.random = new Random(debug1);
+      return this;
+    }
+
+    public Builder withOptionalRandomSeed(long debug1, Random debug3) {
+      if (debug1 == 0L) {
+        this.random = debug3;
+      } else {
+        this.random = new Random(debug1);
+      }
+      return this;
+    }
+
+    public Builder withLuck(float debug1) {
+      this.luck = debug1;
+      return this;
+    }
+
+    public <T> Builder withParameter(LootContextParam<T> debug1, T debug2) {
+      this.params.put(debug1, debug2);
+      return this;
+    }
+
+    public <T> Builder withOptionalParameter(LootContextParam<T> debug1, @Nullable T debug2) {
+      if (debug2 == null) {
+        this.params.remove(debug1);
+      } else {
+        this.params.put(debug1, debug2);
+      }
+      return this;
+    }
+
+    public Builder withDynamicDrop(ResourceLocation debug1, LootContext.DynamicDrop debug2) {
+      LootContext.DynamicDrop debug3 = this.dynamicDrops.put(debug1, debug2);
+      if (debug3 != null)
+        throw new IllegalStateException("Duplicated dynamic drop '" + this.dynamicDrops + "'");
+      return this;
+    }
+
+    public ServerLevel getLevel() {
+      return this.level;
+    }
+
+    public <T> T getParameter(LootContextParam<T> debug1) {
+      T debug2 = (T)this.params.get(debug1);
+      if (debug2 == null)
+        throw new IllegalArgumentException("No parameter " + debug1);
+      return debug2;
+    }
+
+    @Nullable
+    public <T> T getOptionalParameter(LootContextParam<T> debug1) {
+      return (T)this.params.get(debug1);
+    }
+
+    public LootContext create(LootContextParamSet debug1) {
+      Sets.SetView setView1 = Sets.difference(this.params.keySet(), debug1.getAllowed());
+      if (!setView1.isEmpty())
+        throw new IllegalArgumentException("Parameters not allowed in this parameter set: " + setView1);
+      Sets.SetView setView2 = Sets.difference(debug1.getRequired(), this.params.keySet());
+      if (!setView2.isEmpty())
+        throw new IllegalArgumentException("Missing required parameters: " + setView2);
+      Random debug4 = this.random;
+      if (debug4 == null)
+        debug4 = new Random();
+      MinecraftServer debug5 = this.level.getServer();
+      return new LootContext(debug4, this.luck, this.level, debug5.getLootTables()::get, debug5.getPredicateManager()::get, this.params, this.dynamicDrops);
+    }
+  }
+
+  public enum EntityTarget {
+    THIS("this", LootContextParams.THIS_ENTITY),
+    KILLER("killer", LootContextParams.KILLER_ENTITY),
+    DIRECT_KILLER("direct_killer", LootContextParams.DIRECT_KILLER_ENTITY),
+    KILLER_PLAYER("killer_player", LootContextParams.LAST_DAMAGE_PLAYER);
+
+    private final String name;
+
+    private final LootContextParam<? extends Entity> param;
+
+    EntityTarget(String debug3, LootContextParam<? extends Entity> debug4) {
+      this.name = debug3;
+      this.param = debug4;
+    }
+
+    public LootContextParam<? extends Entity> getParam() {
+      return this.param;
+    }
+
+    public static EntityTarget getByName(String debug0) {
+      for (EntityTarget debug4 : values()) {
+        if (debug4.name.equals(debug0))
+          return debug4;
+      }
+      throw new IllegalArgumentException("Invalid entity target " + debug0);
+    }
+
+    public static class Serializer extends TypeAdapter<EntityTarget> {
+      public void write(JsonWriter debug1, LootContext.EntityTarget debug2) throws IOException {
+        debug1.value(debug2.name);
+      }
+
+      public LootContext.EntityTarget read(JsonReader debug1) throws IOException {
+        return LootContext.EntityTarget.getByName(debug1.nextString());
+      }
+    }
+  }
+  // MagmaCube end - decompile fix
 }
diff --git a/src/main/java/net/minecraft/world/phys/HitResult.java b/src/main/java/net/minecraft/world/phys/HitResult.java
index 678bfde644c7b1c3785d7442217fa88bfaff3739..2e9d1d2c128fae069f646fd923c10e4e64da996d 100644
--- a/src/main/java/net/minecraft/world/phys/HitResult.java
+++ b/src/main/java/net/minecraft/world/phys/HitResult.java
@@ -4,6 +4,12 @@ import net.minecraft.world.entity.Entity;
 
 public abstract class HitResult {
   protected final Vec3 location;
+
+  // MagmaCube start - decompile fix
+  public enum Type {
+    MISS, BLOCK, ENTITY;
+  }
+  // MagmaCube end - decompile fix
   
   protected HitResult(Vec3 debug1) {
     this.location = debug1;
